{"backend_state":"running","kernel":"python3","kernel_state":"idle","kernel_usage":{"cpu":0,"memory":83910656},"metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.6.9"},"toc":{"base_numbering":1,"nav_menu":{},"number_sections":true,"sideBar":true,"skip_h1_title":false,"title_cell":"Table of Contents","title_sidebar":"Contents","toc_cell":false,"toc_position":{"height":"calc(100% - 180px)","left":"10px","top":"150px","width":"250.696px"},"toc_section_display":true,"toc_window_display":true},"varInspector":{"cols":{"lenName":16,"lenType":16,"lenVar":40},"kernels_config":{"python":{"delete_cmd_postfix":"","delete_cmd_prefix":"del ","library":"var_list.py","varRefreshCmd":"print(var_dic_list())"},"r":{"delete_cmd_postfix":") ","delete_cmd_prefix":"rm(","library":"var_list.r","varRefreshCmd":"cat(var_dic_list()) "}},"types_to_exclude":["module","function","builtin_function_or_method","instance","_Feature"],"window_display":false}},"trust":true,"type":"settings"}
{"cell_type":"code","exec_count":0,"id":"b0de45","input":"","pos":86,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":1,"id":"b8e958","input":"# EXECUTE FIRST\n\n# computational imports\nimport numpy as np\nimport pandas as pd\nfrom scipy.optimize import minimize\nimport json\n# plotting imports\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nsns.set_style(\"darkgrid\")\n# for reading files from urls\nimport urllib.request\n# display imports\nfrom IPython.display import display, IFrame\nfrom IPython.core.display import HTML\n\n# for playing videos, customize height and width if desired\ndef play_video(vid_name, w = 640, h = 360):\n    vid_path = \"https://media.uwex.edu/content/ds/ds775_r19/\"\n    return IFrame( vid_path + vid_name + \"/index.html\", width = w, height = h )\n\n# import notebook styling for tables and width etc.\nresponse = urllib.request.urlopen('https://raw.githubusercontent.com/DataScienceUWL/DS775v2/master/ds755.css')\nHTML(response.read().decode(\"utf-8\"));\n\n# for this notebook we get rid of a bunch of warnings that don't hurt anything\nimport warnings\nwarnings.filterwarnings('ignore')","metadata":{"code_folding":[0]},"pos":0,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":1,"id":"bdc93a","input":"# execute this cell for video\nfrom IPython.display import IFrame\nIFrame(\n    \"https://media.uwex.edu/content/ds/ds775_r19/ds775_lesson5-simulated-annealing/index.html\",\n    width=640,\n    height=360)","metadata":{"code_folding":[],"hidden":true},"output":{"0":{"data":{"text/html":"\n        <iframe\n            width=\"640\"\n            height=\"360\"\n            src=\"https://media.uwex.edu/content/ds/ds775_r19/ds775_lesson5-simulated-annealing/index.html\"\n            frameborder=\"0\"\n            allowfullscreen\n        ></iframe>\n        ","text/plain":"<IPython.lib.display.IFrame at 0x10d9152b0>"},"exec_count":1,"output_type":"execute_result"}},"pos":6,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":11,"id":"2c53aa","input":"parent1 = np.arange(10) + 10 # use sequences to make it easy to see crossover\nparent2 = parent1 + 10\n\nchild1, child2 = parent1.copy(), parent2.copy()\ncx_point = 3\nchild1[0:cx_point], child2[0:cx_point] = parent2[0:cx_point], parent1[0:cx_point]\n\nprint('Parents')\nprint(parent1)\nprint(parent2)\nprint('\\nChildren')\nprint(child1)\nprint(child2)","output":{"0":{"name":"stdout","output_type":"stream","text":"Parents\n[10 11 12 13 14 15 16 17 18 19]\n[20 21 22 23 24 25 26 27 28 29]\n\nChildren\n[20 21 22 13 14 15 16 17 18 19]\n[10 11 12 23 24 25 26 27 28 29]\n"}},"pos":52,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":12,"id":"1c784d","input":"import numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nsns.set_style(\"darkgrid\")\n\n# define objective function and show a contour plot\n\ndef f(xy):\n    obj = 0.2 + sum(xy**2 - 0.1*np.cos(6*np.pi*xy))\n    return obj\n\n# we could have written the objective function like this for transparency:\n# if the argument is a list with [ numpy array of x's, numpy array of y's]\n# def f(xy):\n#     x = xy[0]\n#     y = xy[1]\n#     obj = 0.2 + x**2 + y**2 - 0.1*np.cos(6*np.pi*x) - 0.1*np.cos(6*np.pi*y)\n#     return obj\n\n# see script for details of plot\n%run scripts/bumpy_contours.py","metadata":{"code_folding":[],"hidden":true},"output":{"0":{"data":{"image/png":"4b0bdf39a46ecdb176a4fbbe00f3335f3e174782","text/plain":"<Figure size 576x576 with 1 Axes>"},"exec_count":12,"metadata":{"image/png":{"height":494,"width":516}},"output_type":"execute_result"}},"pos":22,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":126,"id":"e2e6f2","input":"mut_prob = 1.0 # all individuals can mutate, usually around 0.1 to 0.3\nind_prob = 0.1\nsigma = (upper-lower)/6\nmut_pop = np.zeros((ind_size,pop_size)) # initialize mutation population\nfor j in range(pop_size):\n    individual = cx_pop[:,j].copy() # copy is necessary to avoid conflicts in memory\n    if np.random.uniform()<mut_prob:\n        for i in range(ind_size):\n            if np.random.uniform()<ind_prob:\n                individual[i] += np.random.normal(0,sigma)\n                if individual[i] < lower: # clipping to bounds\n                    individual[i] = lower\n                if individual[i] > upper:\n                    individual[i] = upper\n    mut_pop[:,j] = individual.copy() # copy is necessary to avoid conflicts in memory","pos":60,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":127,"id":"736896","input":"pd.DataFrame(cx_pop[:,0:10]-mut_pop[:,0:10])","output":{"0":{"data":{"text/html":"<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>0</th>\n      <th>1</th>\n      <th>2</th>\n      <th>3</th>\n      <th>4</th>\n      <th>5</th>\n      <th>6</th>\n      <th>7</th>\n      <th>8</th>\n      <th>9</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>0.000000</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>0.000000</td>\n      <td>0.000000</td>\n      <td>0.0</td>\n      <td>-0.234622</td>\n      <td>0.000000</td>\n      <td>0.000000</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>0.000000</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>0.000000</td>\n      <td>0.000000</td>\n      <td>0.0</td>\n      <td>0.000000</td>\n      <td>0.000000</td>\n      <td>0.000000</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>0.261505</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>0.000000</td>\n      <td>0.000000</td>\n      <td>0.0</td>\n      <td>0.000000</td>\n      <td>0.000000</td>\n      <td>0.000000</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>0.000000</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>0.000000</td>\n      <td>0.000000</td>\n      <td>0.0</td>\n      <td>-2.020805</td>\n      <td>0.000000</td>\n      <td>0.000000</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>0.000000</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>0.000000</td>\n      <td>0.000000</td>\n      <td>0.0</td>\n      <td>0.000000</td>\n      <td>0.000000</td>\n      <td>0.000000</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>0.000000</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>2.309510</td>\n      <td>0.000000</td>\n      <td>0.0</td>\n      <td>0.000000</td>\n      <td>0.000000</td>\n      <td>0.000000</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>0.000000</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>0.000000</td>\n      <td>0.000000</td>\n      <td>0.0</td>\n      <td>0.000000</td>\n      <td>0.156727</td>\n      <td>0.491798</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>7</th>\n      <td>0.000000</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>-2.626464</td>\n      <td>0.000000</td>\n      <td>0.0</td>\n      <td>0.000000</td>\n      <td>1.099872</td>\n      <td>0.000000</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>8</th>\n      <td>0.000000</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>0.000000</td>\n      <td>0.000000</td>\n      <td>0.0</td>\n      <td>0.000000</td>\n      <td>0.000000</td>\n      <td>0.000000</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>9</th>\n      <td>0.000000</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>0.000000</td>\n      <td>1.227263</td>\n      <td>0.0</td>\n      <td>0.000000</td>\n      <td>-0.367887</td>\n      <td>0.000000</td>\n      <td>0.0</td>\n    </tr>\n  </tbody>\n</table>\n</div>","text/plain":"          0    1    2         3         4    5         6         7         8  \\\n0  0.000000  0.0  0.0  0.000000  0.000000  0.0 -0.234622  0.000000  0.000000   \n1  0.000000  0.0  0.0  0.000000  0.000000  0.0  0.000000  0.000000  0.000000   \n2  0.261505  0.0  0.0  0.000000  0.000000  0.0  0.000000  0.000000  0.000000   \n3  0.000000  0.0  0.0  0.000000  0.000000  0.0 -2.020805  0.000000  0.000000   \n4  0.000000  0.0  0.0  0.000000  0.000000  0.0  0.000000  0.000000  0.000000   \n5  0.000000  0.0  0.0  2.309510  0.000000  0.0  0.000000  0.000000  0.000000   \n6  0.000000  0.0  0.0  0.000000  0.000000  0.0  0.000000  0.156727  0.491798   \n7  0.000000  0.0  0.0 -2.626464  0.000000  0.0  0.000000  1.099872  0.000000   \n8  0.000000  0.0  0.0  0.000000  0.000000  0.0  0.000000  0.000000  0.000000   \n9  0.000000  0.0  0.0  0.000000  1.227263  0.0  0.000000 -0.367887  0.000000   \n\n     9  \n0  0.0  \n1  0.0  \n2  0.0  \n3  0.0  \n4  0.0  \n5  0.0  \n6  0.0  \n7  0.0  \n8  0.0  \n9  0.0  "},"exec_count":127,"output_type":"execute_result"}},"pos":62,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":15,"id":"a5cea3","input":"%run scripts/bumpy_2d.py","output":{"0":{"data":{"iframe":"f74df480d1455854de59399976ddd6815bfeaf0a"},"exec_count":15,"output_type":"execute_result"}},"pos":24,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":16,"id":"f573fa","input":"fitness = np.random.uniform(0,10,size=5)\nranks = np.argsort(-fitness) + 1\ntotal = sum(ranks)\nprob = ranks/total\nprint(fitness)\nprint(ranks)\nprint(prob)\n","output":{"0":{"name":"stdout","output_type":"stream","text":"[1.86504299 5.19252382 2.53394826 5.15121046 8.56758626]\n[5 2 4 3 1]\n[0.33333333 0.13333333 0.26666667 0.2        0.06666667]\n"}},"pos":85,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":17,"id":"c7b9be","input":"# imports (these are all the packages needed, but we also import them at other points)\nfrom scipy.optimize import minimize\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nsns.set_style(\"darkgrid\")\nimport pandas as pd\nimport json\nimport numpy as np\n\nimport warnings\nwarnings.filterwarnings('ignore')","metadata":{"code_folding":[0]},"pos":1,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":18,"id":"6d5691","input":"# note that the smallest element is in position 3, the second smallest in position 1, the third smallest in postion 0, and the last smallest in position 2\narray = np.array([4,2,7,1])\nsorted_pos = array.argsort()\nsorted_pos","output":{"0":{"data":{"text/plain":"array([3, 1, 0, 2])"},"exec_count":18,"output_type":"execute_result"}},"pos":40,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":19,"id":"2cc7a0","input":"tourn_size = 3\nselect_pop = np.zeros((ind_size,pop_size)) # initialize selected population\nsel_fitness = np.zeros(pop_size)\nfor j in range(pop_size):\n    subset_pos = np.random.choice(pop_size,tourn_size,replace=False) # select without replacement\n    smallest_pos = np.min(subset_pos) # choose index corresponding to lowest fitness\n    select_pop[:,j] = pop[:,smallest_pos]\n    sel_fitness[j] = fitness[smallest_pos]","pos":46,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":2,"id":"50c180","input":"import numpy as np\npop_size = 50 # should be even due to the way we'll implement crossover\nind_size = 10\nlower = -5.12\nupper = 5.12\npop = np.random.uniform(low=lower, high=upper, size = (ind_size,pop_size))","pos":32,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":2,"id":"8dc2b3","input":"# Self-Assessment Solution for Simulated Annealing with Continuous Variables\nimport numpy as np\n\ndef f(xy):\n    obj = 0.2 + sum(xy**2 - 0.1*np.cos(6*np.pi*xy))\n    return obj\n\ndef gauss_move(xy,sigma):\n    # xy is a 1 by dim numpy array\n    # sigma is the standard deviation for the normal distribution\n    dim = len(xy)\n    return xy + np.random.normal(loc = 0, scale = sigma, size=dim)\n\ndef clip_to_bounds(xy,low,high):\n    # xy is a 1 by dim numpy array\n    # low is the lower bound for clipping variables\n    # high is the upper bound for clipping variables\n    return np.array( [min(high,max(low,v)) for v in xy])\n\nfrom simanneal import Annealer\n\nclass NonConvex2D(Annealer):\n\n    # no extra data so just initialize with state\n    def __init__(self, state, sigma, low, high):\n        self.sigma = sigma\n        self.low = low\n        self.high = high\n        super(NonConvex2D, self).__init__(state)  # important!\n\n    def move(self):\n        self.state = gauss_move(self.state, self.sigma)\n        self.state = clip_to_bounds(self.state, self.low, self.high)\n\n    def energy(self):\n        return f(self.state)\n\ninit_state = np.random.uniform(low=-1,high=1,size=2)\nsigma = 1/3\nlow = -1\nhigh = 1\n\nproblem2D = NonConvex2D( init_state, sigma, low, high )\nproblem2D.set_schedule(problem2D.auto(minutes=.2))\nbest_x, best_fun = problem2D.anneal()\n\nprint(\"Notice that the results below are displayed using scientific notation.\\n\")\nprint(f\"The lowest function value found by simulated annealing is {best_fun:.3e}\")\nprint(f\"That value is achieved when x = {best_x[0]:.3e} and y = {best_x[1]:.3e}\")\n# refine with local search\nfrom scipy.optimize import minimize\n\nresult = minimize(f,best_x)\nprint(\"\\nAfter refining the result from simulated annealing with local search.\")\nprint(f\"The lowest function value found by local search is {result.fun:.3e}\")\nprint(f\"That value is achieved when x = {result.x[0]:.3e} and y = {result.x[1]:.3e}\")","output":{"0":{"name":"stderr","output_type":"stream","text":" Temperature        Energy    Accept   Improve     Elapsed   Remaining\n\r     0.00000          0.28                         0:00:00            \r"},"1":{"name":"stderr","output_type":"stream","text":"\r     0.01500          0.02     0.90%     0.35%     0:00:00     0:00:03\r\r"},"10":{"name":"stderr","output_type":"stream","text":"\r     0.54000          1.20    72.65%    35.60%     0:00:01     0:00:01\r\r"},"100":{"name":"stderr","output_type":"stream","text":"\r     0.02911          0.07     3.55%     1.52%     0:00:08     0:00:05\r\r"},"101":{"name":"stderr","output_type":"stream","text":"\r     0.02671          0.00     2.00%     0.94%     0:00:08     0:00:05\r\r"},"102":{"name":"stderr","output_type":"stream","text":"\r     0.02450          0.02     1.45%     0.87%     0:00:08     0:00:05\r\r"},"103":{"name":"stderr","output_type":"stream","text":"\r     0.02248          0.03     1.19%     0.68%     0:00:08     0:00:04\r\r"},"104":{"name":"stderr","output_type":"stream","text":"\r     0.02062          0.00     1.74%     0.87%     0:00:08     0:00:04\r\r"},"105":{"name":"stderr","output_type":"stream","text":"\r     0.01892          0.02     1.06%     0.55%     0:00:09     0:00:04\r\r"},"106":{"name":"stderr","output_type":"stream","text":"\r     0.01736          0.04     1.00%     0.52%     0:00:09     0:00:04\r\r"},"107":{"name":"stderr","output_type":"stream","text":"\r     0.01592          0.01     1.00%     0.58%     0:00:09     0:00:04\r\r"},"108":{"name":"stderr","output_type":"stream","text":"\r     0.01461          0.05     0.97%     0.39%     0:00:09     0:00:04\r\r"},"109":{"name":"stderr","output_type":"stream","text":"\r     0.01340          0.01     0.90%     0.45%     0:00:09     0:00:04\r\r"},"11":{"name":"stderr","output_type":"stream","text":"\r     0.81000          0.56    80.85%    40.50%     0:00:01     0:00:01\r\r"},"110":{"name":"stderr","output_type":"stream","text":"\r     0.01229          0.00     0.48%     0.23%     0:00:09     0:00:04\r\r"},"111":{"name":"stderr","output_type":"stream","text":"\r     0.01128          0.01     0.55%     0.26%     0:00:09     0:00:03\r\r"},"112":{"name":"stderr","output_type":"stream","text":"\r     0.01035          0.00     0.65%     0.29%     0:00:09     0:00:03\r\r"},"113":{"name":"stderr","output_type":"stream","text":"\r     0.00949          0.00     0.45%     0.23%     0:00:10     0:00:03\r\r"},"114":{"name":"stderr","output_type":"stream","text":"\r     0.00871          0.00     0.29%     0.13%     0:00:10     0:00:03\r\r"},"115":{"name":"stderr","output_type":"stream","text":"\r     0.00799          0.00     0.58%     0.26%     0:00:10     0:00:03\r\r"},"116":{"name":"stderr","output_type":"stream","text":"\r     0.00733          0.00     0.13%     0.03%     0:00:10     0:00:03\r\r"},"117":{"name":"stderr","output_type":"stream","text":"\r     0.00672          0.00     0.16%     0.06%     0:00:10     0:00:03\r\r"},"118":{"name":"stderr","output_type":"stream","text":"\r     0.00617          0.01     0.19%     0.10%     0:00:10     0:00:03\r\r"},"119":{"name":"stderr","output_type":"stream","text":"\r     0.00566          0.04     0.48%     0.26%     0:00:10     0:00:02\r\r"},"12":{"name":"stderr","output_type":"stream","text":"\r     1.20000          0.60    86.55%    43.20%     0:00:01     0:00:01\r\r"},"120":{"name":"stderr","output_type":"stream","text":"\r     0.00519          0.00     0.16%     0.13%     0:00:10     0:00:02\r\r"},"121":{"name":"stderr","output_type":"stream","text":"\r     0.00476          0.00     0.29%     0.13%     0:00:10     0:00:02\r\r"},"122":{"name":"stderr","output_type":"stream","text":"\r     0.00437          0.00     0.03%     0.00%     0:00:11     0:00:02\r\r"},"123":{"name":"stderr","output_type":"stream","text":"\r     0.00401          0.00     0.29%     0.13%     0:00:11     0:00:02\r\r"},"124":{"name":"stderr","output_type":"stream","text":"\r     0.00368          0.00     0.16%     0.03%     0:00:11     0:00:02\r\r"},"125":{"name":"stderr","output_type":"stream","text":"\r     0.00337          0.00     0.13%     0.10%     0:00:11     0:00:02\r\r"},"126":{"name":"stderr","output_type":"stream","text":"\r     0.00310          0.01     0.13%     0.03%     0:00:11     0:00:02\r\r"},"127":{"name":"stderr","output_type":"stream","text":"\r     0.00284          0.01     0.23%     0.10%     0:00:11     0:00:01\r\r"},"128":{"name":"stderr","output_type":"stream","text":"\r     0.00260          0.00     0.19%     0.10%     0:00:11     0:00:01\r\r"},"129":{"name":"stderr","output_type":"stream","text":"\r     0.00239          0.00     0.06%     0.03%     0:00:11     0:00:01\r\r"},"13":{"name":"stderr","output_type":"stream","text":"\r     1.80000          0.80    92.60%    46.95%     0:00:01     0:00:01\r\r"},"130":{"name":"stderr","output_type":"stream","text":"\r     0.00219          0.00     0.16%     0.06%     0:00:12     0:00:01\r\r"},"131":{"name":"stderr","output_type":"stream","text":"\r     0.00201          0.00     0.06%     0.03%     0:00:12     0:00:01\r\r"},"132":{"name":"stderr","output_type":"stream","text":"\r     0.00185          0.00     0.10%     0.06%     0:00:12     0:00:01\r\r"},"133":{"name":"stderr","output_type":"stream","text":"\r     0.00169          0.00     0.16%     0.06%     0:00:12     0:00:01\r\r"},"134":{"name":"stderr","output_type":"stream","text":"\r     0.00155          0.00     0.10%     0.06%     0:00:12     0:00:00\r\r"},"135":{"name":"stderr","output_type":"stream","text":"\r     0.00142          0.00     0.06%     0.03%     0:00:12     0:00:00\r\r"},"136":{"name":"stderr","output_type":"stream","text":"\r     0.00131          0.00     0.03%     0.00%     0:00:12     0:00:00\r\r"},"137":{"name":"stderr","output_type":"stream","text":"\r     0.00120          0.00     0.06%     0.03%     0:00:12     0:00:00\r\r"},"138":{"name":"stderr","output_type":"stream","text":"\r     0.00110          0.00     0.13%     0.06%     0:00:12     0:00:00\r\r"},"139":{"name":"stdout","output_type":"stream","text":"Notice that the results below are displayed using scientific notation.\n\nThe lowest function value found by simulated annealing is 1.230e-05\nThat value is achieved when x = -6.661e-04 and y = -4.605e-04\n\nAfter refining the result from simulated annealing with local search.\nThe lowest function value found by local search is 6.005e-13\nThat value is achieved when x = 1.103e-07 and y = -1.408e-07\n"},"14":{"name":"stderr","output_type":"stream","text":"\r     2.70000          0.46    94.45%    46.55%     0:00:01     0:00:01\r\r"},"15":{"name":"stderr","output_type":"stream","text":"\r     4.10000          1.13    96.15%    47.20%     0:00:01     0:00:01\r\r"},"16":{"name":"stderr","output_type":"stream","text":"\r     6.10000          1.10    98.15%    47.75%     0:00:01     0:00:01\r\r"},"17":{"name":"stderr","output_type":"stream","text":"\r     4.10000          0.47    95.55%    45.75%     0:00:01     0:00:01\r\r"},"18":{"name":"stderr","output_type":"stream","text":"\r     2.70000          0.43    94.80%    46.50%     0:00:02     0:00:00\r\r"},"19":{"name":"stderr","output_type":"stream","text":"\r     1.80000          1.07    91.25%    44.85%     0:00:02     0:00:00\r\r"},"2":{"name":"stderr","output_type":"stream","text":"\r     0.02200          0.03     1.10%     0.55%     0:00:00     0:00:02\r\r"},"20":{"name":"stderr","output_type":"stream","text":"\r     1.20000          0.98    87.20%    43.85%     0:00:02     0:00:00\r\r"},"21":{"name":"stderr","output_type":"stream","text":"\r     0.80000          1.06    84.10%    40.30%     0:00:02     0:00:00\r\r"},"22":{"name":"stderr","output_type":"stream","text":"\r     0.53000          0.67    70.95%    34.25%     0:00:02     0:00:00\r\r"},"23":{"name":"stderr","output_type":"stream","text":"\r     0.35000          0.43    64.35%    32.15%     0:00:02     0:00:00\r\r"},"24":{"name":"stderr","output_type":"stream","text":"\r     0.23000          0.12    50.10%    25.15%     0:00:02     0:00:00\r\r"},"25":{"name":"stderr","output_type":"stream","text":"\r     0.15000          0.58    40.40%    20.40%     0:00:02     0:00:00\r\r"},"26":{"name":"stderr","output_type":"stream","text":"\r     0.10000          0.02    26.15%    13.10%     0:00:02     0:00:00\r\r"},"27":{"name":"stderr","output_type":"stream","text":"\r     0.06700          0.25    16.85%     8.55%     0:00:02     0:00:00\r\r"},"28":{"name":"stderr","output_type":"stream","text":"\r     0.04500          0.01     8.05%     3.85%     0:00:02     0:00:00\r\r"},"29":{"name":"stderr","output_type":"stream","text":"\r     0.03000          0.01     3.75%     1.95%     0:00:02     0:00:00\r\r"},"3":{"name":"stderr","output_type":"stream","text":"\r     0.03300          0.15     5.80%     2.65%     0:00:00     0:00:02\r\r"},"30":{"name":"stderr","output_type":"stream","text":"\r     0.02000          0.02     1.80%     0.85%     0:00:02     0:00:00\r\r"},"31":{"name":"stderr","output_type":"stream","text":"\r     0.01300          0.00     0.40%     0.30%     0:00:02    -1:59:59\r\r"},"32":{"name":"stderr","output_type":"stream","text":"\r     0.00870          0.02     0.20%     0.05%     0:00:03    -1:59:59\r\r"},"33":{"name":"stderr","output_type":"stream","text":"\r     0.00580          0.01     0.20%     0.15%     0:00:03    -1:59:59\r\r"},"34":{"name":"stderr","output_type":"stream","text":"\r     0.00390          0.00     0.10%     0.10%     0:00:03    -1:59:59\r\r"},"35":{"name":"stderr","output_type":"stream","text":"\r     0.00260          0.00     0.15%     0.05%     0:00:03    -1:59:59\r\r"},"36":{"name":"stderr","output_type":"stream","text":"\r     0.00170          0.00     0.05%     0.05%     0:00:03    -1:59:59\r\r"},"37":{"name":"stderr","output_type":"stream","text":"\r     0.00110          0.00     0.00%     0.00%     0:00:03    -1:59:59\r\r"},"38":{"name":"stderr","output_type":"stream","text":" Temperature        Energy    Accept   Improve     Elapsed   Remaining\n\r     6.10000          0.00                         0:00:00            \r"},"39":{"name":"stderr","output_type":"stream","text":"\r     5.59616          0.46    97.06%    48.55%     0:00:00     0:00:12\r\r"},"4":{"name":"stderr","output_type":"stream","text":"\r     0.05000          0.03    10.15%     5.05%     0:00:00     0:00:02\r\r"},"40":{"name":"stderr","output_type":"stream","text":"\r     5.13394          1.15    97.52%    48.87%     0:00:00     0:00:13\r\r"},"41":{"name":"stderr","output_type":"stream","text":"\r     4.70990          0.34    96.61%    47.81%     0:00:00     0:00:12\r\r"},"42":{"name":"stderr","output_type":"stream","text":"\r     4.32088          1.08    95.84%    47.06%     0:00:00     0:00:12\r\r"},"43":{"name":"stderr","output_type":"stream","text":"\r     3.96399          1.10    96.58%    47.39%     0:00:01     0:00:13\r\r"},"44":{"name":"stderr","output_type":"stream","text":"\r     3.63658          1.48    95.13%    47.55%     0:00:01     0:00:13\r\r"},"45":{"name":"stderr","output_type":"stream","text":"\r     3.33622          0.53    95.42%    46.90%     0:00:01     0:00:13\r\r"},"46":{"name":"stderr","output_type":"stream","text":"\r     3.06066          0.28    95.29%    46.61%     0:00:01     0:00:13\r\r"},"47":{"name":"stderr","output_type":"stream","text":"\r     2.80786          1.36    94.74%    47.39%     0:00:01     0:00:13\r\r"},"48":{"name":"stderr","output_type":"stream","text":"\r     2.57594          0.66    93.32%    46.10%     0:00:01     0:00:12\r\r"},"49":{"name":"stderr","output_type":"stream","text":"\r     2.36318          0.85    94.13%    46.39%     0:00:01     0:00:12\r\r"},"5":{"name":"stderr","output_type":"stream","text":"\r     0.07500          0.03    19.70%     9.25%     0:00:01     0:00:02\r\r"},"50":{"name":"stderr","output_type":"stream","text":"\r     2.16799          1.05    93.00%    46.29%     0:00:02     0:00:12\r\r"},"51":{"name":"stderr","output_type":"stream","text":"\r     1.98892          0.07    92.19%    45.45%     0:00:02     0:00:11\r\r"},"52":{"name":"stderr","output_type":"stream","text":"\r     1.82465          0.70    92.71%    46.26%     0:00:02     0:00:11\r\r"},"53":{"name":"stderr","output_type":"stream","text":"\r     1.67394          0.72    91.13%    45.61%     0:00:02     0:00:11\r\r"},"54":{"name":"stderr","output_type":"stream","text":"\r     1.53568          0.21    89.81%    43.71%     0:00:02     0:00:11\r\r"},"55":{"name":"stderr","output_type":"stream","text":"\r     1.40884          1.11    88.81%    44.26%     0:00:02     0:00:10\r\r"},"56":{"name":"stderr","output_type":"stream","text":"\r     1.29247          0.50    88.19%    44.87%     0:00:02     0:00:10\r\r"},"57":{"name":"stderr","output_type":"stream","text":"\r     1.18572          1.10    86.71%    42.55%     0:00:02     0:00:10\r\r"},"58":{"name":"stderr","output_type":"stream","text":"\r     1.08778          0.58    86.87%    43.55%     0:00:02     0:00:10\r\r"},"59":{"name":"stderr","output_type":"stream","text":"\r     0.99794          1.21    84.65%    41.06%     0:00:03     0:00:10\r\r"},"6":{"name":"stderr","output_type":"stream","text":"\r     0.11000          0.30    28.10%    14.10%     0:00:01     0:00:02\r\r"},"60":{"name":"stderr","output_type":"stream","text":"\r     0.91551          0.64    83.42%    40.87%     0:00:03     0:00:10\r\r"},"61":{"name":"stderr","output_type":"stream","text":"\r     0.83989          1.40    80.71%    39.97%     0:00:03     0:00:09\r\r"},"62":{"name":"stderr","output_type":"stream","text":"\r     0.77052          1.00    82.32%    41.55%     0:00:03     0:00:09\r\r"},"63":{"name":"stderr","output_type":"stream","text":"\r     0.70688          0.22    79.48%    40.45%     0:00:03     0:00:09\r\r"},"64":{"name":"stderr","output_type":"stream","text":"\r     0.64849          0.17    76.58%    37.48%     0:00:03     0:00:09\r\r"},"65":{"name":"stderr","output_type":"stream","text":"\r     0.59493          0.68    74.45%    37.06%     0:00:03     0:00:09\r\r"},"66":{"name":"stderr","output_type":"stream","text":"\r     0.54579          0.35    75.10%    36.77%     0:00:03     0:00:09\r\r"},"67":{"name":"stderr","output_type":"stream","text":"\r     0.50071          0.39    72.19%    35.87%     0:00:03     0:00:08\r\r"},"68":{"name":"stderr","output_type":"stream","text":"\r     0.45936          0.53    70.19%    34.87%     0:00:04     0:00:08\r\r"},"69":{"name":"stderr","output_type":"stream","text":"\r     0.42141          0.16    67.39%    32.94%     0:00:04     0:00:08\r\r"},"7":{"name":"stderr","output_type":"stream","text":"\r     0.16000          0.28    39.65%    20.00%     0:00:01     0:00:01\r\r"},"70":{"name":"stderr","output_type":"stream","text":"\r     0.38661          0.20    65.87%    32.55%     0:00:04     0:00:08\r\r"},"71":{"name":"stderr","output_type":"stream","text":"\r     0.35467          0.40    63.90%    32.61%     0:00:04     0:00:08\r\r"},"72":{"name":"stderr","output_type":"stream","text":"\r     0.32538          0.67    60.29%    29.10%     0:00:04     0:00:08\r\r"},"73":{"name":"stderr","output_type":"stream","text":"\r     0.29851          0.14    58.00%    29.23%     0:00:04     0:00:08\r\r"},"74":{"name":"stderr","output_type":"stream","text":"\r     0.27385          0.25    58.61%    28.90%     0:00:04     0:00:08\r\r"},"75":{"name":"stderr","output_type":"stream","text":"\r     0.25123          0.27    53.68%    26.29%     0:00:04     0:00:08\r\r"},"76":{"name":"stderr","output_type":"stream","text":"\r     0.23048          0.57    53.35%    26.81%     0:00:05     0:00:07\r\r"},"77":{"name":"stderr","output_type":"stream","text":"\r     0.21144          0.23    51.10%    25.03%     0:00:05     0:00:07\r\r"},"78":{"name":"stderr","output_type":"stream","text":"\r     0.19398          0.04    47.35%    23.32%     0:00:05     0:00:07\r\r"},"79":{"name":"stderr","output_type":"stream","text":"\r     0.17796          0.57    45.06%    22.71%     0:00:05     0:00:07\r\r"},"8":{"name":"stderr","output_type":"stream","text":"\r     0.24000          0.43    53.20%    26.80%     0:00:01     0:00:01\r\r"},"80":{"name":"stderr","output_type":"stream","text":"\r     0.16326          0.13    42.48%    21.48%     0:00:05     0:00:07\r\r"},"81":{"name":"stderr","output_type":"stream","text":"\r     0.14977          0.30    39.71%    19.68%     0:00:05     0:00:07\r\r"},"82":{"name":"stderr","output_type":"stream","text":"\r     0.13740          0.04    36.97%    19.26%     0:00:05     0:00:07\r\r"},"83":{"name":"stderr","output_type":"stream","text":"\r     0.12605          0.27    35.00%    17.68%     0:00:05     0:00:07\r\r"},"84":{"name":"stderr","output_type":"stream","text":"\r     0.11564          0.22    33.06%    16.35%     0:00:06     0:00:06\r\r"},"85":{"name":"stderr","output_type":"stream","text":"\r     0.10609          0.11    31.39%    16.26%     0:00:06     0:00:06\r\r"},"86":{"name":"stderr","output_type":"stream","text":"\r     0.09733          0.21    26.90%    13.48%     0:00:06     0:00:06\r\r"},"87":{"name":"stderr","output_type":"stream","text":"\r     0.08929          0.02    23.81%    11.65%     0:00:06     0:00:06\r\r"},"88":{"name":"stderr","output_type":"stream","text":"\r     0.08191          0.34    22.90%    11.52%     0:00:06     0:00:06\r\r"},"89":{"name":"stderr","output_type":"stream","text":"\r     0.07515          0.15    21.23%    10.58%     0:00:06     0:00:06\r\r"},"9":{"name":"stderr","output_type":"stream","text":"\r     0.36000          1.34    62.40%    30.95%     0:00:01     0:00:01\r\r"},"90":{"name":"stderr","output_type":"stream","text":"\r     0.06894          0.01    17.84%     9.55%     0:00:06     0:00:06\r\r"},"91":{"name":"stderr","output_type":"stream","text":"\r     0.06325          0.15    14.84%     7.52%     0:00:06     0:00:06\r\r"},"92":{"name":"stderr","output_type":"stream","text":"\r     0.05802          0.14    14.97%     8.00%     0:00:07     0:00:06\r\r"},"93":{"name":"stderr","output_type":"stream","text":"\r     0.05323          0.19    13.23%     6.68%     0:00:07     0:00:06\r\r"},"94":{"name":"stderr","output_type":"stream","text":"\r     0.04883          0.03     8.68%     4.13%     0:00:07     0:00:06\r\r"},"95":{"name":"stderr","output_type":"stream","text":"\r     0.04480          0.11     7.42%     3.61%     0:00:07     0:00:05\r\r"},"96":{"name":"stderr","output_type":"stream","text":"\r     0.04110          0.19     7.32%     3.58%     0:00:07     0:00:05\r\r"},"97":{"name":"stderr","output_type":"stream","text":"\r     0.03771          0.01     6.00%     3.10%     0:00:08     0:00:05\r\r"},"98":{"name":"stderr","output_type":"stream","text":"\r     0.03459          0.05     5.13%     2.68%     0:00:08     0:00:05\r\r"},"99":{"name":"stderr","output_type":"stream","text":"\r     0.03173          0.03     4.74%     2.42%     0:00:08     0:00:05\r\r"}},"pos":27,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":2,"id":"f2606a","input":"import numpy as np\n\npop_size = 100 # should be even due to the way we'll implement crossover\nind_size = 10 # determines number of input variables for Rastrigin and each individual\nlower = -5.12 # lower and upper bounds on the real variables\nupper = 5.12\ntourn_size = 3 # tournament size for selection\ncx_prob = 0.8 # probability a pair of parents crossover to produce two children\nmut_prob = 0.2 # probability an individual mutates\nind_prob = 0.1 # probability each variable in an individual mutates\nsigma = (upper-lower)/6 # standard deviation (scale) for gaussian mutations\nnum_iter = 2000 # number of genetic algorithm mutations\nupdate_iter = 100 # how often to display output\n\nstats = np.zeros((num_iter+1,3)) # for collecting statistics\n\n# objective or fitness function\ndef rastrigin(x):\n    x = np.array(x) # force a numpy arrray here so that the math below works\n    return np.sum(x**2 + 10 - 10 * np.cos(2 * np.pi * x) )\n\n#initialize population and fitness\npop = np.random.uniform(low=lower, high=upper, size = (ind_size,pop_size))\nfitness = np.zeros(pop_size)\nfor j in range(pop_size):\n    fitness[j] = rastrigin(pop[:,j])\n\n# initialize stats and output\nbest_fitness = min(fitness)\nstats[0,:] = np.array([0,best_fitness, best_fitness])\nprint('Iteration | Best this iter |    Best ever')\n\nfor iter in range(num_iter):\n    # tournament selection\n    sorted_pos = fitness.argsort() # sort pop by increasing fitness\n    fitness = fitness[sorted_pos]\n    pop = pop[:,sorted_pos]\n    select_pop = np.zeros((ind_size,pop_size)) # initialize selected population\n    for j in range(pop_size):\n        subset_pos = np.random.choice(pop_size,tourn_size,replace=False) # select without replacement\n        smallest_pos = np.min(subset_pos) # choose index corresponding to lowest fitness\n        select_pop[:,j] = pop[:,smallest_pos]\n\n    # one-point crossover (mating)\n    cx_pop = np.zeros((ind_size,pop_size)) # initialize crossover population\n    for j in range(int(pop_size/2)):  # pop_size must be even\n        parent1, parent2 = select_pop[:,2*j], select_pop[:,2*j+1]\n        child1, child2 = parent1.copy(), parent2.copy()\n        if np.random.uniform() < cx_prob: # crossover occurs\n            cx_point = np.random.randint(1,ind_size) # crossover point between 0 and ind_size-2\n            child1[0:cx_point], child2[0:cx_point] = parent2[0:cx_point], parent1[0:cx_point]\n        cx_pop[:,2*j] = child1\n        cx_pop[:,2*j+1] = child2\n\n    # gaussian mutation (rewritten to remove nested loop for speed)\n    mut_pop = np.zeros((ind_size,pop_size)) # initialize mutation population\n    for j in range(pop_size):\n        individual = cx_pop[:,j].copy() # copy is necessary to avoid conflicts in memory\n        if np.random.uniform()<mut_prob:\n            individual = individual + np.random.normal(0,sigma,ind_size)*(np.random.uniform(size=ind_size)<ind_prob)\n            individual = np.maximum(individual,lower) # clip to lower bound\n            individual = np.minimum(individual,upper) # clip to upper bound\n        mut_pop[:,j] = individual.copy() # copy is necessary to avoid conflicts in memory\n\n    # fitness evaluation with local search\n    pop = mut_pop.copy()\n    for j in range(pop_size):\n        fitness[j] = rastrigin(pop[:,j])\n\n    # collect stats and output to screen\n    min_fitness = min(fitness) # best for this iteration\n    if min_fitness < best_fitness: # best for all iterations\n        best_fitness = min_fitness\n        index = np.argmin(fitness)\n        best_x = pop[:,index]\n\n    stats[iter+1,:] = np.array([iter+1,min_fitness, best_fitness])\n    if (iter+1) % update_iter == 0:\n        print(f\"{stats[iter+1,0]:9.0f} | {stats[iter+1,1]:14.3e} | {stats[iter+1,2]:12.3e}\")\n        \nprint(f\"The minimum value found of the Rastrigin function is {best_fitness:.4f}\")\nprint(\"The location of that minimum is:\")\nprint('(',', '.join(f\"{x:.4f}\" for x in best_x),')')","output":{"0":{"name":"stdout","output_type":"stream","text":"Iteration | Best this iter |    Best ever\n"},"1":{"name":"stdout","output_type":"stream","text":"      100 |      2.037e+00 |    2.037e+00\n"},"10":{"name":"stdout","output_type":"stream","text":"     1000 |      7.210e-02 |    7.210e-02\n"},"11":{"name":"stdout","output_type":"stream","text":"     1100 |      4.891e-02 |    4.891e-02\n"},"12":{"name":"stdout","output_type":"stream","text":"     1200 |      4.277e-02 |    4.277e-02\n"},"13":{"name":"stdout","output_type":"stream","text":"     1300 |      3.798e-02 |    3.798e-02\n"},"14":{"name":"stdout","output_type":"stream","text":"     1400 |      3.798e-02 |    3.798e-02\n"},"15":{"name":"stdout","output_type":"stream","text":"     1500 |      3.504e-02 |    3.504e-02\n"},"16":{"name":"stdout","output_type":"stream","text":"     1600 |      2.847e-02 |    2.847e-02\n"},"17":{"name":"stdout","output_type":"stream","text":"     1700 |      1.018e-02 |    1.018e-02\n"},"18":{"name":"stdout","output_type":"stream","text":"     1800 |      7.950e-03 |    7.950e-03\n"},"19":{"name":"stdout","output_type":"stream","text":"     1900 |      7.635e-03 |    7.124e-03\n"},"2":{"name":"stdout","output_type":"stream","text":"      200 |      7.962e-01 |    7.962e-01\n"},"20":{"name":"stdout","output_type":"stream","text":"     2000 |      7.635e-03 |    7.124e-03\nThe minimum value found of the Rastrigin function is 0.0071\nThe location of that minimum is:\n( 0.0017, 0.0000, -0.0023, -0.0025, -0.0013, 0.0020, -0.0000, 0.0034, -0.0011, -0.0019 )\n"},"3":{"name":"stdout","output_type":"stream","text":"      300 |      5.024e-01 |    4.487e-01\n"},"4":{"name":"stdout","output_type":"stream","text":"      400 |      1.260e-01 |    1.260e-01\n"},"5":{"name":"stdout","output_type":"stream","text":"      500 |      1.259e-01 |    1.259e-01\n"},"6":{"name":"stdout","output_type":"stream","text":"      600 |      8.529e-02 |    8.529e-02\n"},"7":{"name":"stdout","output_type":"stream","text":"      700 |      8.529e-02 |    8.529e-02\n"},"8":{"name":"stdout","output_type":"stream","text":"      800 |      8.529e-02 |    8.529e-02\n"},"9":{"name":"stdout","output_type":"stream","text":"      900 |      7.210e-02 |    7.210e-02\n"}},"pos":67,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":20,"id":"ff3409","input":"fitness","output":{"0":{"data":{"text/plain":"array([124.2196413 , 133.01651861, 133.27698183, 136.29209057,\n       140.28885231, 140.96483667, 146.84919357, 148.01894738,\n       148.13384713, 153.05704686, 159.14473589, 160.07273418,\n       168.16559327, 168.38256783, 169.56175691, 170.54128505,\n       171.03079018, 175.28197184, 175.56388436, 176.18361372,\n       179.32258203, 181.04969631, 184.49372573, 185.29448192,\n       185.88345102, 186.53950704, 192.06415473, 192.16218245,\n       192.89924497, 195.3027411 , 200.10535023, 200.48661612,\n       202.41948654, 204.4261079 , 205.01468098, 208.94950979,\n       210.33426359, 211.03625944, 211.12702956, 211.51485557,\n       214.20930765, 214.4334837 , 214.6463253 , 215.41731089,\n       218.23840282, 223.61273853, 235.17412673, 240.35896704,\n       269.5327568 , 273.64008877])"},"exec_count":20,"output_type":"execute_result"}},"pos":48,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":21,"id":"f34c06","input":"sel_fitness","output":{"0":{"data":{"text/plain":"array([169.56175691, 133.27698183, 205.01468098, 192.16218245,\n       148.01894738, 184.49372573, 153.05704686, 136.29209057,\n       133.27698183, 175.28197184, 133.01651861, 140.28885231,\n       175.28197184, 133.27698183, 169.56175691, 185.29448192,\n       159.14473589, 160.07273418, 185.88345102, 146.84919357,\n       148.01894738, 175.56388436, 169.56175691, 148.01894738,\n       148.13384713, 146.84919357, 168.38256783, 169.56175691,\n       133.27698183, 168.16559327, 168.16559327, 159.14473589,\n       136.29209057, 170.54128505, 148.13384713, 192.89924497,\n       175.28197184, 208.94950979, 170.54128505, 175.28197184,\n       175.56388436, 153.05704686, 133.01651861, 140.96483667,\n       133.01651861, 169.56175691, 175.56388436, 204.4261079 ,\n       124.2196413 , 171.03079018])"},"exec_count":21,"output_type":"execute_result"}},"pos":49,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":22,"id":"e18c66","input":"cx_prob = .8 # prob. that a pair produces offspring\ncx_pop = np.zeros((ind_size,pop_size)) # initialize crossover population\nfor j in range(int(pop_size/2)):  # pop_size must be even\n    parent1, parent2 = select_pop[:,2*j], select_pop[:,2*j+1]\n    child1, child2 = parent1.copy(), parent2.copy()\n    if np.random.uniform() < cx_prob: # crossover occurs\n        cx_point = np.random.randint(1,ind_size) # crossover point between 0 and ind_size-2\n        child1[0:cx_point], child2[0:cx_point] = parent2[0:cx_point], parent1[0:cx_point]\n    cx_pop[:,2*j] = child1\n    cx_pop[:,2*j+1] = child2","pos":54,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":23,"id":"f958ed","input":"import pandas as pd\nprint('Columns are first 6 parents')\npd.DataFrame(select_pop[:,0:6])","output":{"0":{"data":{"text/html":"<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>0</th>\n      <th>1</th>\n      <th>2</th>\n      <th>3</th>\n      <th>4</th>\n      <th>5</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>0.695287</td>\n      <td>2.423418</td>\n      <td>3.222039</td>\n      <td>-1.729806</td>\n      <td>-2.124399</td>\n      <td>0.182859</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>1.288604</td>\n      <td>0.952327</td>\n      <td>-3.112494</td>\n      <td>-1.954731</td>\n      <td>2.778655</td>\n      <td>-3.118564</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>1.870486</td>\n      <td>-0.699644</td>\n      <td>-4.544328</td>\n      <td>2.424679</td>\n      <td>2.703089</td>\n      <td>-4.532371</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>3.710283</td>\n      <td>0.285575</td>\n      <td>3.646852</td>\n      <td>0.509586</td>\n      <td>0.844354</td>\n      <td>-3.888007</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>1.775207</td>\n      <td>2.876319</td>\n      <td>3.628706</td>\n      <td>-4.406843</td>\n      <td>-4.287206</td>\n      <td>2.439462</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>-3.336088</td>\n      <td>-1.460028</td>\n      <td>0.539046</td>\n      <td>2.322675</td>\n      <td>0.229236</td>\n      <td>0.793081</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>-0.174184</td>\n      <td>-1.202220</td>\n      <td>3.241387</td>\n      <td>-4.974397</td>\n      <td>1.774092</td>\n      <td>-3.708352</td>\n    </tr>\n    <tr>\n      <th>7</th>\n      <td>-2.238535</td>\n      <td>0.636418</td>\n      <td>1.254498</td>\n      <td>2.204954</td>\n      <td>4.914272</td>\n      <td>0.271560</td>\n    </tr>\n    <tr>\n      <th>8</th>\n      <td>3.920612</td>\n      <td>-2.231147</td>\n      <td>-2.767601</td>\n      <td>2.461246</td>\n      <td>0.718825</td>\n      <td>2.544428</td>\n    </tr>\n    <tr>\n      <th>9</th>\n      <td>-4.711376</td>\n      <td>-0.234634</td>\n      <td>-1.879746</td>\n      <td>1.832667</td>\n      <td>2.903286</td>\n      <td>-0.269756</td>\n    </tr>\n  </tbody>\n</table>\n</div>","text/plain":"          0         1         2         3         4         5\n0  0.695287  2.423418  3.222039 -1.729806 -2.124399  0.182859\n1  1.288604  0.952327 -3.112494 -1.954731  2.778655 -3.118564\n2  1.870486 -0.699644 -4.544328  2.424679  2.703089 -4.532371\n3  3.710283  0.285575  3.646852  0.509586  0.844354 -3.888007\n4  1.775207  2.876319  3.628706 -4.406843 -4.287206  2.439462\n5 -3.336088 -1.460028  0.539046  2.322675  0.229236  0.793081\n6 -0.174184 -1.202220  3.241387 -4.974397  1.774092 -3.708352\n7 -2.238535  0.636418  1.254498  2.204954  4.914272  0.271560\n8  3.920612 -2.231147 -2.767601  2.461246  0.718825  2.544428\n9 -4.711376 -0.234634 -1.879746  1.832667  2.903286 -0.269756"},"exec_count":23,"output_type":"execute_result"}},"pos":56,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":24,"id":"97329f","input":"pd.DataFrame(cx_pop[:,0:6])","output":{"0":{"data":{"text/html":"<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>0</th>\n      <th>1</th>\n      <th>2</th>\n      <th>3</th>\n      <th>4</th>\n      <th>5</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>2.423418</td>\n      <td>0.695287</td>\n      <td>-1.729806</td>\n      <td>3.222039</td>\n      <td>-2.124399</td>\n      <td>0.182859</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>0.952327</td>\n      <td>1.288604</td>\n      <td>-3.112494</td>\n      <td>-1.954731</td>\n      <td>2.778655</td>\n      <td>-3.118564</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>-0.699644</td>\n      <td>1.870486</td>\n      <td>-4.544328</td>\n      <td>2.424679</td>\n      <td>2.703089</td>\n      <td>-4.532371</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>0.285575</td>\n      <td>3.710283</td>\n      <td>3.646852</td>\n      <td>0.509586</td>\n      <td>0.844354</td>\n      <td>-3.888007</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>2.876319</td>\n      <td>1.775207</td>\n      <td>3.628706</td>\n      <td>-4.406843</td>\n      <td>-4.287206</td>\n      <td>2.439462</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>-1.460028</td>\n      <td>-3.336088</td>\n      <td>0.539046</td>\n      <td>2.322675</td>\n      <td>0.229236</td>\n      <td>0.793081</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>-1.202220</td>\n      <td>-0.174184</td>\n      <td>3.241387</td>\n      <td>-4.974397</td>\n      <td>1.774092</td>\n      <td>-3.708352</td>\n    </tr>\n    <tr>\n      <th>7</th>\n      <td>-2.238535</td>\n      <td>0.636418</td>\n      <td>1.254498</td>\n      <td>2.204954</td>\n      <td>4.914272</td>\n      <td>0.271560</td>\n    </tr>\n    <tr>\n      <th>8</th>\n      <td>3.920612</td>\n      <td>-2.231147</td>\n      <td>-2.767601</td>\n      <td>2.461246</td>\n      <td>0.718825</td>\n      <td>2.544428</td>\n    </tr>\n    <tr>\n      <th>9</th>\n      <td>-4.711376</td>\n      <td>-0.234634</td>\n      <td>-1.879746</td>\n      <td>1.832667</td>\n      <td>2.903286</td>\n      <td>-0.269756</td>\n    </tr>\n  </tbody>\n</table>\n</div>","text/plain":"          0         1         2         3         4         5\n0  2.423418  0.695287 -1.729806  3.222039 -2.124399  0.182859\n1  0.952327  1.288604 -3.112494 -1.954731  2.778655 -3.118564\n2 -0.699644  1.870486 -4.544328  2.424679  2.703089 -4.532371\n3  0.285575  3.710283  3.646852  0.509586  0.844354 -3.888007\n4  2.876319  1.775207  3.628706 -4.406843 -4.287206  2.439462\n5 -1.460028 -3.336088  0.539046  2.322675  0.229236  0.793081\n6 -1.202220 -0.174184  3.241387 -4.974397  1.774092 -3.708352\n7 -2.238535  0.636418  1.254498  2.204954  4.914272  0.271560\n8  3.920612 -2.231147 -2.767601  2.461246  0.718825  2.544428\n9 -4.711376 -0.234634 -1.879746  1.832667  2.903286 -0.269756"},"exec_count":24,"output_type":"execute_result"}},"pos":57,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":3,"id":"280277","input":"pop[:,0:5]","output":{"0":{"data":{"text/plain":"array([[ 1.57308744,  4.44171706,  3.22203898, -4.21170382,  0.18285903],\n       [-4.42169044, -1.89143342, -3.11249427, -0.68001161, -3.11856432],\n       [-2.18003916, -2.4364995 , -4.54432817, -1.43643628, -4.53237104],\n       [-3.28656113, -0.00523941,  3.64685244, -3.45682204, -3.8880066 ],\n       [-1.47975479,  0.29568266,  3.62870571,  2.95035342,  2.4394623 ],\n       [-2.0784638 , -2.1403632 ,  0.53904596, -4.04562046,  0.79308067],\n       [ 2.76963753, -1.07923548,  3.24138684,  2.91073235, -3.70835236],\n       [ 4.29775151, -0.92647211,  1.25449844, -1.74725414,  0.27155982],\n       [-3.29902763, -2.87695123, -2.76760117, -1.00016252,  2.54442789],\n       [ 3.86446636, -3.88376473, -1.87974576,  5.0186202 , -0.26975614]])"},"exec_count":3,"output_type":"execute_result"}},"pos":34,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":3,"id":"58f9bb","input":"# Ordered Crossover on Sequences in Numpy\nimport numpy as np\n\nparent1 = np.array([0, 1, 2, 3, 4, 5, 6])\nparent2 = np.array([3, 5, 6, 2, 0, 4, 1])\n\nind_size = parent1.shape[0]\n\n# uncomment the line below to choose subsequence randomly in your code\n# swap_idx = np.sort(np.random.randint(0,ind_size,2))\n\n# delete this for your code, we want a fixed sequence for our example\nswap_idx = np.array([ 3, 5]) # subseq in positions 3 through 5 inclusive\n\nchild1,child2 = parent2.copy(), parent1.copy()\n\nhole = np.full( ind_size, False, dtype = bool)\nhole[swap_idx[0]:swap_idx[1]+1] = True\n\nchild1[~hole] = np.array([x for x in parent1 if x not in parent2[hole]])\nchild2[~hole] = np.array([x for x in parent2 if x not in parent1[hole]])\n\nprint(hole)\nprint(parent1[hole])\nprint(parent2[hole])\nprint(parent1,parent2)\nprint(child1,child2)","output":{"0":{"name":"stdout","output_type":"stream","text":"[False False False  True  True  True False]\n[3 4 5]\n[2 0 4]\n[0 1 2 3 4 5 6] [3 5 6 2 0 4 1]\n[1 3 5 2 0 4 6] [6 2 0 3 4 5 1]\n"}},"pos":71,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":30,"id":"6993b0","input":"pop = mut_pop.copy()\nfor j in range(pop_size):\n    fitness[j] = rastrigin(pop[:,j])\nfitness[0:10]","output":{"0":{"data":{"text/plain":"array([0.06596337, 0.06596337, 5.20249791, 0.06596337, 0.06596337,\n       0.06596337, 0.06596337, 0.06596337, 0.06596337, 0.06596337])"},"exec_count":30,"output_type":"execute_result"}},"pos":65,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":37,"id":"d64e4d","input":"import pandas as pd\nimport numpy as np\n\n# load the data + random assignment\nnum_districts = 10\nmin_voters_in_district = 150\nmax_voters_in_district = 350\n\ndems = [152,81,75,34,62,38,48,74,98,66,83,86,72,28,112,45,93,72]\nreps = [62,59,83,52,87,87,69,49,62,72,75,82,83,53,98,82,68,98]\ncities = pd.DataFrame( data = {'dems':dems, 'reps':reps})\nnum_cities = len(dems)\n\n# uses penalty to 'discourage' out of bounds solutions\ndef fitness_districts(assign, cities, num_districts):\n    df = cities.groupby(assign).sum()\n    fitness = sum( df['reps'] > df['dems'] )\n    total_voters = np.zeros(num_districts,dtype=np.int32)\n    total_voters[df.index] = df.sum(axis=1)\n    fitness -= np.abs(np.minimum(np.maximum(total_voters,150),350)-total_voters).sum()\n    return (-fitness)\n\ndef move_cities(assign,num_districts,ind_prob):\n    num_cities = assign.shape[0] # or len(assign)\n    new_assign = assign.copy()\n    for j in range(num_cities):\n        if np.random.uniform() < ind_prob:\n            while new_assign[j] == assign[j]: # loops until new and old are different\n                new_assign[j] = np.random.randint(num_districts)\n    return new_assign\n    \ndef summarize_districts(assign, cities):\n    reps = np.zeros(num_districts, dtype=np.int32)\n    dems = np.zeros(num_districts, dtype=np.int32)\n    df = cities.groupby(assign).sum()\n    reps[df.index] = df['reps']\n    dems[df.index] = df['dems']\n    total = reps + dems\n    delta = np.minimum(np.maximum(total, min_voters_in_district),\n                       max_voters_in_district) - total\n    rep_win = reps > dems\n    dict = {\n        'reps': reps,\n        'dems': dems,\n        'total': total,\n        'rep_win': rep_win\n    }\n    return (pd.DataFrame(data=dict))","metadata":{"code_folding":[]},"pos":77,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":39,"id":"909ce6","input":"import numpy as np\n\npop_size = 20 # should be even due to the way we'll implement crossover\nind_size = num_cities # determines number of input variables for Rastrigin and each individual\n# bounds are included in the fitness function so we don't need these\n#lower = -5.12 # lower and upper bounds on the real variables\n#upper = 5.12\ntourn_size = 3 # tournament size for selection\ncx_prob = 0.7 # probability a pair of parents crossover to produce two children\nmut_prob = 0.3 # probability an individual mutates\nind_prob = 0.1 # probability each variable in an individual mutates\n# sigma is only needed for gaussian mutation\n#sigma = (upper-lower)/6 # standard deviation (scale) for gaussian mutations\nnum_iter = 1000 # number of genetic algorithm mutations\nupdate_iter = 100 # how often to display output\n\nstats = np.zeros((num_iter+1,3)) # for collecting statistics\n\n# objective or fitness function\n\n#initialize population and fitness\npop = np.random.randint(low=0, high=num_districts, size = (ind_size,pop_size))\nfitness = np.empty(pop_size)\nfor j in range(pop_size):\n    fitness[j] = fitness_districts(pop[:,j],cities,num_districts)\nbest_fitness = min(fitness)\nstats[0,:] = np.array([0,best_fitness, best_fitness])\nprint('Iteration | Best this iter |    Best ever')\n\nfor iter in range(num_iter):\n    # tournament selection\n    sorted_pos = fitness.argsort() # sort pop by increasing fitness\n    fitness = fitness[sorted_pos]\n    pop = pop[:,sorted_pos]\n    select_pop = np.zeros((ind_size,pop_size)) # initialize selected population\n    for j in range(pop_size):\n        subset_pos = np.random.choice(pop_size,tourn_size,replace=False) # select without replacement\n        smallest_pos = np.min(subset_pos) # choose index corresponding to lowest fitness\n        select_pop[:,j] = pop[:,smallest_pos]\n\n    # one-point crossover (mating)\n    cx_pop = np.zeros((ind_size,pop_size)) # initialize crossover population\n    for j in range(int(pop_size/2)):  # pop_size must be even\n        child1 = select_pop[:,2*j] # these are the parents, but we'll swap pieces in place\n        child2 = select_pop[:,2*j+1]\n        if np.random.uniform() < cx_prob: # crossover occurs\n            cx_point = np.random.randint(0,ind_size-1) # crossover point between 0 and ind_size-2\n            child1[0:cx_point+1], child2[0:cx_point+1] = child2[0:cx_point+1], child1[0:cx_point+1]\n        cx_pop[:,2*j] = child1\n        cx_pop[:,2*j+1] = child2\n\n    # mutuation\n    mut_pop = cx_pop.copy()\n    for j in range(pop_size):\n        if np.random.uniform()<mut_prob:\n            mut_pop[:,j] = move_cities(mut_pop[:,j], num_districts, ind_prob)\n\n    # fitness evaluation\n    pop = mut_pop.copy().astype(int)\n    for j in range(pop_size):\n        fitness[j] = fitness_districts(pop[:,j],cities,num_districts)\n\n    # collect stats and output to screen\n    min_fitness = min(fitness) # best for this iteration\n    if min_fitness < best_fitness: # best for all iterations\n        best_fitness = min_fitness\n        index = np.argmin(fitness)\n        best_x = pop[:,index]\n\n    stats[iter+1,:] = np.array([iter+1,min_fitness, best_fitness])\n    if (iter+1) % update_iter == 0:\n        print(f\"{stats[iter+1,0]:9.0f} | {stats[iter+1,1]:14.3e} | {stats[iter+1,2]:12.3e}\")\n        \nprint(f\"The maximum number of districts won by Republicans is {-best_fitness:.0f}\")\nprint(\"The location of that maximum  is:\")\nprint('(',', '.join(f\"{x:.0f}\" for x in best_x),')')","output":{"0":{"name":"stdout","output_type":"stream","text":"Iteration | Best this iter |    Best ever\n"},"1":{"name":"stdout","output_type":"stream","text":"      100 |     -7.000e+00 |   -7.000e+00\n"},"10":{"name":"stdout","output_type":"stream","text":"     1000 |     -8.000e+00 |   -8.000e+00\nThe maximum number of districts won by Republicans is 8\nThe location of that maximum  is:\n( 5, 8, 1, 0, 3, 7, 4, 2, 6, 1, 3, 9, 9, 4, 0, 2, 7, 8 )\n"},"2":{"name":"stdout","output_type":"stream","text":"      200 |     -7.000e+00 |   -7.000e+00\n"},"3":{"name":"stdout","output_type":"stream","text":"      300 |     -7.000e+00 |   -7.000e+00\n"},"4":{"name":"stdout","output_type":"stream","text":"      400 |     -7.000e+00 |   -7.000e+00\n"},"5":{"name":"stdout","output_type":"stream","text":"      500 |     -8.000e+00 |   -8.000e+00\n"},"6":{"name":"stdout","output_type":"stream","text":"      600 |     -8.000e+00 |   -8.000e+00\n"},"7":{"name":"stdout","output_type":"stream","text":"      700 |     -8.000e+00 |   -8.000e+00\n"},"8":{"name":"stdout","output_type":"stream","text":"      800 |     -8.000e+00 |   -8.000e+00\n"},"9":{"name":"stdout","output_type":"stream","text":"      900 |     -8.000e+00 |   -8.000e+00\n"}},"pos":78,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":4,"id":"4cb479","input":"import json\nimport numpy as np\nfrom simanneal import Annealer\n\ndef tour_distance(tour, dist_mat):\n    distance = dist_mat[tour[-1]][tour[0]]\n    for gene1, gene2 in zip(tour[0:-1], tour[1:]):\n        distance += dist_mat[gene1][gene2]\n    return distance\n\ndef sub_tour_reversal(tour):\n    # reverse a random tour segment\n    num_cities = len(tour)\n    i, j = np.sort(np.random.choice(num_cities, 2, replace=False))\n    return np.concatenate((tour[0:i], tour[j:-num_cities + i - 1:-1],\n                              tour[j + 1:num_cities]))\n\nclass TravellingSalesmanProblem(Annealer):\n\n    # pass extra data (the distance matrix) into the constructor\n    def __init__(self, state, distance_matrix):\n        self.distance_matrix = distance_matrix\n        super(TravellingSalesmanProblem, self).__init__(state)  # important!\n\n    def move(self):\n        self.state = sub_tour_reversal(self.state)\n    \n    def energy(self):\n        return tour_distance(self.state, self.distance_matrix)\n\nimport json\n\n# load data (this may have to be adapted for different problems)\nwith open(\"data/HillierTSP.json\", \"r\") as tsp_data:\n    tsp = json.load(tsp_data)\ndistance_matrix = tsp[\"DistanceMatrix\"]\ninit_tour = np.random.permutation(np.arange(len(distance_matrix))).tolist()\n\ntsp = TravellingSalesmanProblem(init_tour, distance_matrix)\ntsp.set_schedule(tsp.auto(minutes=.2)) #set approximate time to find results\n\nbest_tour, best_dist = tsp.anneal()\n\nbest_dist","metadata":{"hidden":true},"output":{"0":{"name":"stderr","output_type":"stream","text":" Temperature        Energy    Accept   Improve     Elapsed   Remaining\n\r     0.00000        245.00                         0:00:00            \r"},"1":{"name":"stderr","output_type":"stream","text":"\r   130.00000        428.00    75.30%    30.30%     0:00:00     0:00:03\r\r"},"10":{"name":"stderr","output_type":"stream","text":"\r  1000.00000        240.00    96.60%    41.15%     0:00:01     0:00:02\r\r"},"100":{"name":"stderr","output_type":"stream","text":"\r     5.75408         69.00    25.24%     5.29%     0:00:10     0:00:04\r\r"},"101":{"name":"stderr","output_type":"stream","text":"\r     5.28547         68.00    25.71%     5.76%     0:00:10     0:00:04\r\r"},"102":{"name":"stderr","output_type":"stream","text":"\r     4.85502         65.00    24.57%     5.43%     0:00:10     0:00:04\r\r"},"103":{"name":"stderr","output_type":"stream","text":"\r     4.45963         63.00    23.19%     4.14%     0:00:10     0:00:04\r\r"},"104":{"name":"stderr","output_type":"stream","text":"\r     4.09645         65.00    24.86%     5.57%     0:00:10     0:00:04\r\r"},"105":{"name":"stderr","output_type":"stream","text":"\r     3.76283         68.00    22.62%     4.43%     0:00:10     0:00:03\r\r"},"106":{"name":"stderr","output_type":"stream","text":"\r     3.45639         66.00    23.33%     5.05%     0:00:11     0:00:03\r\r"},"107":{"name":"stderr","output_type":"stream","text":"\r     3.17491         63.00    22.10%     4.05%     0:00:11     0:00:03\r\r"},"108":{"name":"stderr","output_type":"stream","text":"\r     2.91634         65.00    22.48%     3.71%     0:00:11     0:00:03\r\r"},"109":{"name":"stderr","output_type":"stream","text":"\r     2.67884         64.00    23.29%     3.95%     0:00:11     0:00:03\r\r"},"11":{"name":"stderr","output_type":"stream","text":"\r   670.00000        339.00    95.65%    40.00%     0:00:01     0:00:02\r\r"},"110":{"name":"stderr","output_type":"stream","text":"\r     2.46068         68.00    23.05%     4.33%     0:00:11     0:00:03\r\r"},"111":{"name":"stderr","output_type":"stream","text":"\r     2.26028         64.00    21.81%     3.67%     0:00:11     0:00:03\r\r"},"112":{"name":"stderr","output_type":"stream","text":"\r     2.07621         65.00    21.33%     3.48%     0:00:11     0:00:02\r\r"},"113":{"name":"stderr","output_type":"stream","text":"\r     1.90712         64.00    19.71%     3.00%     0:00:11     0:00:02\r\r"},"114":{"name":"stderr","output_type":"stream","text":"\r     1.75181         65.00    16.29%     1.38%     0:00:12     0:00:02\r\r"},"115":{"name":"stderr","output_type":"stream","text":"\r     1.60914         63.00    18.57%     2.71%     0:00:12     0:00:02\r\r"},"116":{"name":"stderr","output_type":"stream","text":"\r     1.47809         66.00    17.57%     2.33%     0:00:12     0:00:02\r\r"},"117":{"name":"stderr","output_type":"stream","text":"\r     1.35772         63.00    19.10%     2.86%     0:00:12     0:00:02\r\r"},"118":{"name":"stderr","output_type":"stream","text":"\r     1.24715         63.00    18.57%     2.10%     0:00:12     0:00:02\r\r"},"119":{"name":"stderr","output_type":"stream","text":"\r     1.14558         63.00    17.52%     1.38%     0:00:12     0:00:02\r\r"},"12":{"name":"stderr","output_type":"stream","text":"\r   450.00000        341.00    93.00%    38.80%     0:00:02     0:00:01\r\r"},"120":{"name":"stderr","output_type":"stream","text":"\r     1.05229         63.00    15.43%     0.48%     0:00:13     0:00:01\r\r"},"121":{"name":"stderr","output_type":"stream","text":"\r     0.96659         65.00    17.00%     1.71%     0:00:13     0:00:01\r\r"},"122":{"name":"stderr","output_type":"stream","text":"\r     0.88787         63.00    14.24%     0.24%     0:00:13     0:00:01\r\r"},"123":{"name":"stderr","output_type":"stream","text":"\r     0.81556         64.00    15.00%     0.24%     0:00:13     0:00:01\r\r"},"124":{"name":"stderr","output_type":"stream","text":"\r     0.74914         65.00    17.29%     1.76%     0:00:13     0:00:01\r\r"},"125":{"name":"stderr","output_type":"stream","text":"\r     0.68813         63.00    14.05%     0.76%     0:00:13     0:00:01\r\r"},"126":{"name":"stderr","output_type":"stream","text":"\r     0.63209         63.00    12.38%     0.00%     0:00:13     0:00:01\r\r"},"127":{"name":"stderr","output_type":"stream","text":"\r     0.58062         63.00    15.57%     0.00%     0:00:14     0:00:00\r\r"},"128":{"name":"stderr","output_type":"stream","text":"\r     0.53333         63.00    13.48%     0.00%     0:00:14     0:00:00\r\r"},"129":{"name":"stderr","output_type":"stream","text":"\r     0.48990         63.00    13.86%     0.00%     0:00:14     0:00:00\r\r"},"13":{"name":"stderr","output_type":"stream","text":"\r   300.00000        243.00    87.95%    36.30%     0:00:02     0:00:01\r\r"},"130":{"name":"stderr","output_type":"stream","text":"\r     0.45000         63.00    13.43%     0.00%     0:00:14     0:00:00\r\r"},"131":{"data":{"text/plain":"63"},"exec_count":4,"output_type":"execute_result"},"14":{"name":"stderr","output_type":"stream","text":"\r   200.00000        334.00    83.85%    34.60%     0:00:02     0:00:01\r\r"},"15":{"name":"stderr","output_type":"stream","text":"\r   130.00000        339.00    76.15%    30.70%     0:00:02     0:00:01\r\r"},"16":{"name":"stderr","output_type":"stream","text":"\r    87.00000        338.00    65.20%    25.55%     0:00:02     0:00:01\r\r"},"17":{"name":"stderr","output_type":"stream","text":"\r    58.00000        341.00    54.65%    20.05%     0:00:02     0:00:01\r\r"},"18":{"name":"stderr","output_type":"stream","text":"\r    39.00000        249.00    40.10%    13.20%     0:00:02     0:00:01\r\r"},"19":{"name":"stderr","output_type":"stream","text":"\r    26.00000         64.00    31.05%     8.45%     0:00:02     0:00:01\r\r"},"2":{"name":"stderr","output_type":"stream","text":"\r   200.00000        245.00    82.95%    33.80%     0:00:00     0:00:03\r\r"},"20":{"name":"stderr","output_type":"stream","text":"\r    17.00000         65.00    27.90%     7.05%     0:00:02     0:00:00\r\r"},"21":{"name":"stderr","output_type":"stream","text":"\r    11.00000         63.00    25.75%     5.80%     0:00:03     0:00:00\r\r"},"22":{"name":"stderr","output_type":"stream","text":"\r     7.30000         64.00    24.75%     4.60%     0:00:03     0:00:00\r\r"},"23":{"name":"stderr","output_type":"stream","text":"\r     4.90000         69.00    23.15%     4.20%     0:00:03     0:00:00\r\r"},"24":{"name":"stderr","output_type":"stream","text":"\r     3.30000         63.00    24.55%     4.85%     0:00:03     0:00:00\r\r"},"25":{"name":"stderr","output_type":"stream","text":"\r     2.20000         65.00    20.05%     3.10%     0:00:03     0:00:00\r\r"},"26":{"name":"stderr","output_type":"stream","text":"\r     1.50000         63.00    21.10%     3.25%     0:00:03     0:00:00\r\r"},"27":{"name":"stderr","output_type":"stream","text":"\r     1.00000         63.00    15.25%     0.65%     0:00:03     0:00:00\r\r"},"28":{"name":"stderr","output_type":"stream","text":"\r     0.67000         63.00    17.20%     1.15%     0:00:03     0:00:00\r\r"},"29":{"name":"stderr","output_type":"stream","text":"\r     0.45000         63.00    13.15%     0.00%     0:00:03    -1:59:59\r\r"},"3":{"name":"stderr","output_type":"stream","text":"\r   300.00000        243.00    89.25%    37.10%     0:00:01     0:00:03\r\r"},"30":{"name":"stderr","output_type":"stream","text":" Temperature        Energy    Accept   Improve     Elapsed   Remaining\n\r  2200.00000         63.00                         0:00:00            \r"},"31":{"name":"stderr","output_type":"stream","text":"\r  2020.83372        433.00    98.43%    41.38%     0:00:00     0:00:13\r\r"},"32":{"name":"stderr","output_type":"stream","text":"\r  1856.25859        343.00    97.90%    42.10%     0:00:00     0:00:12\r\r"},"33":{"name":"stderr","output_type":"stream","text":"\r  1705.08634        246.00    97.62%    42.00%     0:00:00     0:00:12\r\r"},"34":{"name":"stderr","output_type":"stream","text":"\r  1566.22544        250.00    97.67%    42.00%     0:00:00     0:00:12\r\r"},"35":{"name":"stderr","output_type":"stream","text":"\r  1438.67326        427.00    97.90%    41.00%     0:00:01     0:00:12\r\r"},"36":{"name":"stderr","output_type":"stream","text":"\r  1321.50883        245.00    97.71%    41.67%     0:00:01     0:00:12\r\r"},"37":{"name":"stderr","output_type":"stream","text":"\r  1213.88619        151.00    97.71%    40.33%     0:00:01     0:00:12\r\r"},"38":{"name":"stderr","output_type":"stream","text":"\r  1115.02824        245.00    97.62%    40.67%     0:00:01     0:00:11\r\r"},"39":{"name":"stderr","output_type":"stream","text":"\r  1024.22121        341.00    96.38%    40.05%     0:00:01     0:00:11\r\r"},"4":{"name":"stderr","output_type":"stream","text":"\r   450.00000        431.00    91.95%    37.90%     0:00:01     0:00:03\r\r"},"40":{"name":"stderr","output_type":"stream","text":"\r   940.80943         66.00    96.38%    41.19%     0:00:01     0:00:11\r\r"},"41":{"name":"stderr","output_type":"stream","text":"\r   864.19065        429.00    96.10%    41.10%     0:00:01     0:00:11\r\r"},"42":{"name":"stderr","output_type":"stream","text":"\r   793.81164        245.00    95.62%    39.29%     0:00:01     0:00:11\r\r"},"43":{"name":"stderr","output_type":"stream","text":"\r   729.16424        249.00    95.38%    40.29%     0:00:02     0:00:11\r\r"},"44":{"name":"stderr","output_type":"stream","text":"\r   669.78167         68.00    95.76%    39.57%     0:00:02     0:00:11\r\r"},"45":{"name":"stderr","output_type":"stream","text":"\r   615.23517        243.00    94.00%    39.00%     0:00:02     0:00:12\r\r"},"46":{"name":"stderr","output_type":"stream","text":"\r   565.13090        427.00    93.29%    38.57%     0:00:02     0:00:12\r\r"},"47":{"name":"stderr","output_type":"stream","text":"\r   519.10708        251.00    93.48%    39.24%     0:00:02     0:00:12\r\r"},"48":{"name":"stderr","output_type":"stream","text":"\r   476.83140        156.00    92.71%    38.86%     0:00:02     0:00:11\r\r"},"49":{"name":"stderr","output_type":"stream","text":"\r   437.99863        244.00    91.76%    37.95%     0:00:03     0:00:11\r\r"},"5":{"name":"stderr","output_type":"stream","text":"\r   680.00000        160.00    94.90%    40.05%     0:00:01     0:00:02\r\r"},"50":{"name":"stderr","output_type":"stream","text":"\r   402.32836        340.00    91.52%    37.95%     0:00:03     0:00:11\r\r"},"51":{"name":"stderr","output_type":"stream","text":"\r   369.56305        337.00    91.57%    38.62%     0:00:03     0:00:11\r\r"},"52":{"name":"stderr","output_type":"stream","text":"\r   339.46613        158.00    90.33%    38.00%     0:00:03     0:00:10\r\r"},"53":{"name":"stderr","output_type":"stream","text":"\r   311.82027        241.00    90.24%    37.62%     0:00:03     0:00:10\r\r"},"54":{"name":"stderr","output_type":"stream","text":"\r   286.42587        344.00    89.19%    36.05%     0:00:03     0:00:10\r\r"},"55":{"name":"stderr","output_type":"stream","text":"\r   263.09957        158.00    86.76%    35.00%     0:00:03     0:00:10\r\r"},"56":{"name":"stderr","output_type":"stream","text":"\r   241.67295        154.00    86.24%    36.00%     0:00:03     0:00:10\r\r"},"57":{"name":"stderr","output_type":"stream","text":"\r   221.99129        251.00    85.14%    34.52%     0:00:04     0:00:10\r\r"},"58":{"name":"stderr","output_type":"stream","text":"\r   203.91249        251.00    83.19%    33.86%     0:00:04     0:00:10\r\r"},"59":{"name":"stderr","output_type":"stream","text":"\r   187.30602        157.00    81.52%    34.14%     0:00:04     0:00:09\r\r"},"6":{"name":"stderr","output_type":"stream","text":"\r  1000.00000        419.00    96.10%    40.20%     0:00:01     0:00:02\r\r"},"60":{"name":"stderr","output_type":"stream","text":"\r   172.05196        434.00    82.62%    33.14%     0:00:04     0:00:09\r\r"},"61":{"name":"stderr","output_type":"stream","text":"\r   158.04018        158.00    80.19%    32.38%     0:00:04     0:00:09\r\r"},"62":{"name":"stderr","output_type":"stream","text":"\r   145.16952        330.00    76.52%    30.19%     0:00:04     0:00:09\r\r"},"63":{"name":"stderr","output_type":"stream","text":"\r   133.34702        160.00    76.67%    29.86%     0:00:04     0:00:09\r\r"},"64":{"name":"stderr","output_type":"stream","text":"\r   122.48735        332.00    75.62%    30.19%     0:00:04     0:00:09\r\r"},"65":{"name":"stderr","output_type":"stream","text":"\r   112.51207        156.00    74.52%    29.19%     0:00:05     0:00:08\r\r"},"66":{"name":"stderr","output_type":"stream","text":"\r   103.34918        152.00    70.29%    27.95%     0:00:05     0:00:08\r\r"},"67":{"name":"stderr","output_type":"stream","text":"\r    94.93250        156.00    66.67%    26.00%     0:00:05     0:00:09\r\r"},"68":{"name":"stderr","output_type":"stream","text":"\r    87.20127         63.00    65.76%    25.52%     0:00:05     0:00:08\r\r"},"69":{"name":"stderr","output_type":"stream","text":"\r    80.09967        159.00    61.95%    23.90%     0:00:05     0:00:08\r\r"},"7":{"name":"stderr","output_type":"stream","text":"\r  1500.00000        245.00    97.35%    40.45%     0:00:01     0:00:02\r\r"},"70":{"name":"stderr","output_type":"stream","text":"\r    73.57641         66.00    58.81%    22.00%     0:00:05     0:00:08\r\r"},"71":{"name":"stderr","output_type":"stream","text":"\r    67.58441        241.00    55.81%    20.67%     0:00:06     0:00:08\r\r"},"72":{"name":"stderr","output_type":"stream","text":"\r    62.08039        249.00    55.29%    20.00%     0:00:06     0:00:08\r\r"},"73":{"name":"stderr","output_type":"stream","text":"\r    57.02461        158.00    52.33%    17.86%     0:00:06     0:00:08\r\r"},"74":{"name":"stderr","output_type":"stream","text":"\r    52.38057         66.00    50.52%    18.57%     0:00:06     0:00:08\r\r"},"75":{"name":"stderr","output_type":"stream","text":"\r    48.11474        156.00    46.38%    15.57%     0:00:06     0:00:07\r\r"},"76":{"name":"stderr","output_type":"stream","text":"\r    44.19631         66.00    42.10%    14.24%     0:00:06     0:00:07\r\r"},"77":{"name":"stderr","output_type":"stream","text":"\r    40.59700         65.00    42.67%    14.62%     0:00:06     0:00:07\r\r"},"78":{"name":"stderr","output_type":"stream","text":"\r    37.29081         68.00    40.19%    13.14%     0:00:06     0:00:07\r\r"},"79":{"name":"stderr","output_type":"stream","text":"\r    34.25387        154.00    38.33%    11.62%     0:00:07     0:00:07\r\r"},"8":{"name":"stderr","output_type":"stream","text":"\r  2200.00000        341.00    98.70%    41.80%     0:00:01     0:00:02\r\r"},"80":{"name":"stderr","output_type":"stream","text":"\r    31.46427         68.00    38.86%    12.29%     0:00:07     0:00:07\r\r"},"81":{"name":"stderr","output_type":"stream","text":"\r    28.90184         68.00    34.48%     9.19%     0:00:07     0:00:07\r\r"},"82":{"name":"stderr","output_type":"stream","text":"\r    26.54810         64.00    31.19%     8.52%     0:00:07     0:00:06\r\r"},"83":{"name":"stderr","output_type":"stream","text":"\r    24.38604         68.00    30.52%     7.95%     0:00:07     0:00:06\r\r"},"84":{"name":"stderr","output_type":"stream","text":"\r    22.40006         69.00    29.19%     7.90%     0:00:07     0:00:06\r\r"},"85":{"name":"stderr","output_type":"stream","text":"\r    20.57582         69.00    29.81%     8.29%     0:00:08     0:00:06\r\r"},"86":{"name":"stderr","output_type":"stream","text":"\r    18.90014         63.00    28.76%     7.33%     0:00:08     0:00:06\r\r"},"87":{"name":"stderr","output_type":"stream","text":"\r    17.36093         65.00    30.67%     8.00%     0:00:08     0:00:06\r\r"},"88":{"name":"stderr","output_type":"stream","text":"\r    15.94707         65.00    27.90%     6.71%     0:00:08     0:00:06\r\r"},"89":{"name":"stderr","output_type":"stream","text":"\r    14.64835         69.00    25.33%     6.29%     0:00:08     0:00:06\r\r"},"9":{"name":"stderr","output_type":"stream","text":"\r  1500.00000        335.00    97.55%    41.50%     0:00:01     0:00:02\r\r"},"90":{"name":"stderr","output_type":"stream","text":"\r    13.45540         66.00    27.86%     6.52%     0:00:08     0:00:06\r\r"},"91":{"name":"stderr","output_type":"stream","text":"\r    12.35960         66.00    27.48%     6.29%     0:00:08     0:00:05\r\r"},"92":{"name":"stderr","output_type":"stream","text":"\r    11.35305         69.00    27.57%     6.67%     0:00:09     0:00:05\r\r"},"93":{"name":"stderr","output_type":"stream","text":"\r    10.42846         65.00    25.33%     5.86%     0:00:09     0:00:05\r\r"},"94":{"name":"stderr","output_type":"stream","text":"\r     9.57918         64.00    25.38%     6.33%     0:00:09     0:00:05\r\r"},"95":{"name":"stderr","output_type":"stream","text":"\r     8.79906         68.00    26.57%     5.76%     0:00:09     0:00:05\r\r"},"96":{"name":"stderr","output_type":"stream","text":"\r     8.08247         69.00    24.90%     5.57%     0:00:09     0:00:05\r\r"},"97":{"name":"stderr","output_type":"stream","text":"\r     7.42424         69.00    25.48%     6.57%     0:00:09     0:00:05\r\r"},"98":{"name":"stderr","output_type":"stream","text":"\r     6.81961         65.00    27.05%     6.48%     0:00:09     0:00:04\r\r"},"99":{"name":"stderr","output_type":"stream","text":"\r     6.26423         65.00    24.86%     5.38%     0:00:10     0:00:04\r\r"}},"pos":15,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":4,"id":"51366a","input":"def rastrigin(x):\n    x = np.array(x) # force a numpy arrray here so that the math below works\n    return np.sum(x**2 + 10 - 10 * np.cos(2 * np.pi * x) )\n\nfitness = np.zeros(pop_size) # initialize fitness array\nfor j in range(pop_size):\n    fitness[j] = rastrigin(pop[:,j])","pos":36,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":4,"id":"5a180c","input":"# execute this cell for video\nfrom IPython.display import IFrame\nIFrame(\n    \"https://media.uwex.edu/content/ds/ds775_r19/ds775_lesson5-simulated-annealing-package/index.html\",\n    width=640,\n    height=360)","metadata":{"hidden":true},"output":{"0":{"data":{"text/html":"\n        <iframe\n            width=\"640\"\n            height=\"360\"\n            src=\"https://media.uwex.edu/content/ds/ds775_r19/ds775_lesson5-simulated-annealing-package/index.html\"\n            frameborder=\"0\"\n            allowfullscreen\n        ></iframe>\n        ","text/plain":"<IPython.lib.display.IFrame at 0x10d915550>"},"exec_count":4,"output_type":"execute_result"}},"pos":14,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":48,"id":"800e17","input":"array[sorted_pos]","output":{"0":{"data":{"text/plain":"array([1, 2, 4, 7])"},"exec_count":48,"output_type":"execute_result"}},"pos":42,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":5,"id":"18c0ea","input":"fitness[0:5]","output":{"0":{"data":{"text/plain":"array([211.12702956, 124.2196413 , 205.01468098, 168.38256783,\n       184.49372573])"},"exec_count":5,"output_type":"execute_result"}},"pos":38,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":51,"id":"32ac26","input":"import random\n\ndef cxOrdered(ind1, ind2):\n    \"\"\"Executes an ordered crossover (OX) on the input\n    individuals. The two individuals are modified in place. This crossover\n    expects :term:`sequence` individuals of indices, the result for any other\n    type of individuals is unpredictable.\n    :param ind1: The first individual participating in the crossover.\n    :param ind2: The second individual participating in the crossover.\n    :returns: A tuple of two individuals.\n    Moreover, this crossover generates holes in the input\n    individuals. A hole is created when an attribute of an individual is\n    between the two crossover points of the other individual. Then it rotates\n    the element so that all holes are between the crossover points and fills\n    them with the removed elements in order. For more details see\n    [Goldberg1989]_.\n    This function uses the :func:`~random.sample` function from the python base\n    :mod:`random` module.\n    .. [Goldberg1989] Goldberg. Genetic algorithms in search,\n       optimization and machine learning. Addison Wesley, 1989\n    \"\"\"\n    size = min(len(ind1), len(ind2))\n    a, b = random.sample(range(size), 2)\n    if a > b:\n        a, b = b, a\n\n    holes1, holes2 = [True] * size, [True] * size\n    for i in range(size):\n        if i < a or i > b:\n            holes1[ind2[i]] = False\n            holes2[ind1[i]] = False\n\n    # We must keep the original values somewhere before scrambling everything\n    temp1, temp2 = ind1, ind2\n    k1, k2 = b + 1, b + 1\n    for i in range(size):\n        if not holes1[temp1[(i + b + 1) % size]]:\n            ind1[k1 % size] = temp1[(i + b + 1) % size]\n            k1 += 1\n\n        if not holes2[temp2[(i + b + 1) % size]]:\n            ind2[k2 % size] = temp2[(i + b + 1) % size]\n            k2 += 1\n\n    # Swap the content between a and b (included)\n    for i in range(a, b + 1):\n        ind1[i], ind2[i] = ind2[i], ind1[i]\n\n    return ind1, ind2\n\nind1 =  np.array([0,1,2,3,4,5,6,7,8])\nind2 = np.array([7,5,3,1,8,6,4,2,0])\nchild1, child2 = cxOrdered(ind1,ind2)\nprint(child1)\nprint(child2)\nchild2","output":{"0":{"name":"stdout","output_type":"stream","text":"[7 5 3 1 8 6 4 2 0]\n[0 1 2 3 4 5 6 7 8]\n"},"1":{"data":{"text/plain":"array([0, 1, 2, 3, 4, 5, 6, 7, 8])"},"exec_count":51,"output_type":"execute_result"}},"pos":80,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":6,"id":"8b3e0c","input":"sorted_pos = fitness.argsort()\nfitness = fitness[sorted_pos]\npop = pop[:,sorted_pos]\nfitness[0:10]","output":{"0":{"data":{"text/plain":"array([124.2196413 , 133.01651861, 133.27698183, 136.29209057,\n       140.28885231, 140.96483667, 146.84919357, 148.01894738,\n       148.13384713, 153.05704686])"},"exec_count":6,"output_type":"execute_result"}},"pos":44,"scrolled":true,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":6,"id":"f905ef","input":"pop = np.empty((7,10),dtype=int) # create empty array for ind_size = 7 and pop_size = 10\nfor j in range(10):\n    pop[:,j] = np.random.permutation(7)\n    \npop","output":{"0":{"data":{"text/plain":"array([[6, 3, 0, 1, 6, 1, 1, 6, 1, 6],\n       [5, 1, 2, 3, 1, 4, 3, 4, 4, 4],\n       [0, 5, 4, 0, 4, 2, 0, 0, 5, 1],\n       [4, 0, 6, 2, 2, 6, 6, 3, 0, 2],\n       [1, 4, 5, 6, 3, 0, 2, 1, 2, 3],\n       [3, 2, 3, 5, 0, 5, 5, 5, 3, 0],\n       [2, 6, 1, 4, 5, 3, 4, 2, 6, 5]])"},"exec_count":6,"output_type":"execute_result"}},"pos":84,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":7,"id":"531b94","input":"import numpy as np\nimport json\n\n# load data (this may have to be adapted for different problems)\nwith open(\"data/HillierTSP.json\", \"r\") as tsp_data:\n    tsp = json.load(tsp_data)\ndistance_matrix = tsp[\"DistanceMatrix\"]\nindividual_size = tsp[\"TourSize\"]\n\n# define objective function\ndef tour_distance(individual, dist_mat):\n    distance = dist_mat[individual[-1]][individual[0]]\n    for gene1, gene2 in zip(individual[0:-1], individual[1:]):\n        distance += dist_mat[gene1][gene2]\n    return distance\n\ndef sub_tour_reversal(tour):\n    # reverse a random tour segment\n    num_cities = len(tour)\n    i, j = np.sort(np.random.choice(num_cities, 2, replace=False))\n    return np.concatenate((tour[0:i], tour[j:-num_cities + i - 1:-1],\n                              tour[j + 1:num_cities]))\n\n# Random Number Seed\n# if you want reproducible results, then uncomment the following line\n# and play with the seed value until you get a result you like. If you run \n# it again with the same value, then you'll get the same result.\n# np.random.seed(123)\n\ndef simanneal_tsp(init_state, dist_mat, max_no_improve, init_temp, alpha): ###\n    '''\n    We use state to refer to the values of the input variable(s) for the objective function.  \n    For the TSP problem, the state is a tour of the cities.\n    We use obj to refer to the objective function value.\n    For the TSP problem, obj is the total distance of the tour.\n    \n    To adapt this for another minimization problem, \n    only the lines with tour_distance and sub_tour_reversal need to change \n    to give a different objective function and a different move function.\n    Additional arguments to the objective function should be passed into the search function\n    similar to how we passed in dist_mat abov\n    '''\n\n    curr_state = init_state\n    curr_obj = tour_distance(curr_state, dist_mat)\n    best_state = curr_state  ###\n    best_obj = curr_obj  ###\n\n    # stop search if no better state is found within max_no_improve iterations\n    num_moves_no_improve = 0\n    iterations = 0\n    temp = init_temp\n\n    # save history for plotting after optimization\n    history = np.array([[iterations, curr_obj, best_obj]])  ###\n\n    while (num_moves_no_improve < max_no_improve):\n        num_moves_no_improve += 1\n        iterations += 1  # just for tracking\n        new_state = sub_tour_reversal(curr_state) # make a move\n        new_obj = tour_distance(new_state, dist_mat)\n        delta = curr_obj - new_obj ###\n        prob = np.exp(min(delta, 0) / temp) ### # compute prob accept uphill move\n\n        if new_obj < curr_obj or np.random.uniform() < prob : ### # accept if decrease or rand < prob\n            curr_state = new_state\n            curr_obj = new_obj\n            if curr_obj < best_obj: ### # keep track of best ever\n                best_state = curr_state ###\n                best_obj = curr_obj ###\n                num_moves_no_improve = 0 ###\n\n        temp *= alpha ###\n\n        history = np.vstack( (history, np.array([[iterations,curr_obj,best_obj]]) ) ) ###\n\n    return best_state, best_obj, iterations, history\n\n# apply the simanneal_tsp() function to our seven city problem\nnum_cities = len(distance_matrix)\ninit_tour = np.random.permutation(np.arange(num_cities))\n\nbest_tour, best_dist, iterations, history = simanneal_tsp(init_tour, distance_matrix, 200, 100, .995)\nbest_dist","metadata":{"hidden":true},"output":{"0":{"data":{"text/plain":"63"},"exec_count":7,"output_type":"execute_result"}},"pos":8,"scrolled":true,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":75,"id":"43343b","input":"ind1 =  np.array([0,1,2,3,4,5,6,7,8])\nind2 = np.array([7,5,3,1,8,6,4,2,0])\nind_size = ind1.shape[0]\nswap_indices = np.sort(np.random.randint(0,ind_size,2))\nleft,right = swap_indices[0],swap_indices[1]\nprint(left,right)\n\nhole = np.full( ind_size, False, dtype = bool)\nhole[left:right+1] = True\nprint(hole)\n\nswap1 = ind1[hole]\nswap2 = ind2[hole]\nprint(swap1,swap2)\n\nelse1 = np.array([x for x in ind2 if x not in swap1])\nelse2 = np.array([x for x in ind1 if x not in swap2])\nprint(else1,else2)\n\nchild1,child2 = ind2.copy(),ind1.copy()\nchild1[~hole] = else2\nchild2[~hole] = else1\n\nprint(child1,child2)\n","output":{"0":{"name":"stdout","output_type":"stream","text":"4 5\n[False False False False  True  True False False False]\n[4 5] [8 6]\n[7 3 1 8 6 2 0] [0 1 2 3 4 5 7]\n[0 1 2 3 8 6 4 5 7] [7 3 1 8 4 5 6 2 0]\n"}},"pos":81,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":79,"id":"db51ec","input":"np.random.randint(0,2,size=(4,10)).astype(bool)","output":{"0":{"data":{"text/plain":"array([[False, False,  True,  True,  True,  True,  True,  True,  True,\n         True],\n       [ True,  True, False, False,  True,  True,  True,  True,  True,\n        False],\n       [ True, False,  True, False,  True,  True, False,  True,  True,\n         True],\n       [False, False, False, False,  True, False, False, False, False,\n         True]])"},"exec_count":79,"output_type":"execute_result"}},"pos":82,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":8,"id":"4575b3","input":"# plot the progress of the search for visualization\n\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nsns.set_style(\"darkgrid\")\n\nfig = plt.figure(figsize=(8, 6))\nline_min, = plt.plot(history[:,0], history[:,1], label='Curr. Dist.',color='red')\nline_curr, = plt.plot(history[:,0],history[:,2], label='Best. Dist.')\nplt.xlabel('Generation')\nplt.ylabel('Distance')\nplt.legend(handles=[line_curr, line_min])\nplt.title('Smallest Dist. Found: {:d}'.format(int(best_dist)));","metadata":{"hidden":true},"output":{"0":{"data":{"image/png":"9f96192ffce2c5178b8a243b6d46f780a5640611","text/plain":"<Figure size 576x432 with 1 Axes>"},"exec_count":8,"metadata":{"image/png":{"height":385,"width":497}},"output_type":"execute_result"}},"pos":9,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":81,"id":"7b16c6","input":"np.random.permutation(7)","output":{"0":{"data":{"text/plain":"array([3, 5, 6, 2, 0, 4, 1])"},"exec_count":81,"output_type":"execute_result"}},"pos":83,"state":"done","type":"cell"}
{"cell_type":"code","exec_count":9,"id":"d65f9e","input":"import pandas as pd\nimport numpy as np\n\npop = np.empty((7,10),dtype=int) # create empty array for ind_size = 7 and pop_size = 10\nfor j in range(10):\n    pop[:,j] = np.random.permutation(7)\n\npd.DataFrame(pop)","output":{"0":{"data":{"text/html":"<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>0</th>\n      <th>1</th>\n      <th>2</th>\n      <th>3</th>\n      <th>4</th>\n      <th>5</th>\n      <th>6</th>\n      <th>7</th>\n      <th>8</th>\n      <th>9</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>3</td>\n      <td>1</td>\n      <td>0</td>\n      <td>1</td>\n      <td>6</td>\n      <td>2</td>\n      <td>3</td>\n      <td>4</td>\n      <td>2</td>\n      <td>5</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>2</td>\n      <td>4</td>\n      <td>3</td>\n      <td>2</td>\n      <td>4</td>\n      <td>4</td>\n      <td>6</td>\n      <td>5</td>\n      <td>1</td>\n      <td>4</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>4</td>\n      <td>6</td>\n      <td>4</td>\n      <td>5</td>\n      <td>2</td>\n      <td>3</td>\n      <td>2</td>\n      <td>3</td>\n      <td>4</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>5</td>\n      <td>3</td>\n      <td>6</td>\n      <td>3</td>\n      <td>0</td>\n      <td>0</td>\n      <td>1</td>\n      <td>6</td>\n      <td>3</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>1</td>\n      <td>0</td>\n      <td>2</td>\n      <td>6</td>\n      <td>1</td>\n      <td>5</td>\n      <td>5</td>\n      <td>0</td>\n      <td>6</td>\n      <td>6</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>0</td>\n      <td>5</td>\n      <td>5</td>\n      <td>4</td>\n      <td>5</td>\n      <td>6</td>\n      <td>4</td>\n      <td>2</td>\n      <td>0</td>\n      <td>2</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>6</td>\n      <td>2</td>\n      <td>1</td>\n      <td>0</td>\n      <td>3</td>\n      <td>1</td>\n      <td>0</td>\n      <td>1</td>\n      <td>5</td>\n      <td>3</td>\n    </tr>\n  </tbody>\n</table>\n</div>","text/plain":"   0  1  2  3  4  5  6  7  8  9\n0  3  1  0  1  6  2  3  4  2  5\n1  2  4  3  2  4  4  6  5  1  4\n2  4  6  4  5  2  3  2  3  4  1\n3  5  3  6  3  0  0  1  6  3  0\n4  1  0  2  6  1  5  5  0  6  6\n5  0  5  5  4  5  6  4  2  0  2\n6  6  2  1  0  3  1  0  1  5  3"},"exec_count":9,"output_type":"execute_result"}},"pos":73,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"0ed82e","input":"If we now index the array using the sorted_pos as the index we'll get the elements of the array in increasing order:","pos":41,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"1e3060","input":"To visualize the mutations we'll print out the difference in the first 10 individuals between the crossover population and the new mutated population.  Most of the differences should be zero, but approximately 10% will differ by the random amount selected from the normal distribution:","pos":61,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"2bea14","input":"Let's print out the first 5 values of fitness corresponding to the first 5 individuals (columns) of the population","pos":37,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"3be4bd","input":"Copy the gerrymandering code from Lesson 4 and adapt the simulated annealing code above to try to find a solution in which republicans win 9 of the 10 districts.  Beware that you're trying to maximize the fitness.  The simplest way to use a minimization algorithm to maximize is to negate the fitness value.  If you start with simanneal_tsp then you should need only minor changes.\n\nYou'll have to change the values of the initial temperature, max_no_improve, and alpha.  The positive initial temperature should be similar to the initial fitness values (in magnitude).  Increasing max_no_improve allows the search to explore for longer.  Increasing alpha means the temperature doesn't decrease as quickly so that more uphill moves are allowed and the algorithm can explore more of the search space.","metadata":{"hidden":true},"pos":11,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"413c82","input":"## Other Selection Operators\n\nOther kinds of selection are possible, but we've found tournament selection to work well in practice.  Choosing small tournament sizes (> 1) leads to a more diverse selection process while large tournament sizes tend to promote only the fittest members of the population.  We won't explore other selection operators in the homework.","pos":74,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"4360c3","input":"## Using the `simanneal` package (video)","metadata":{"heading_collapsed":true,"hidden":true},"pos":12,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"49decb","input":"About 80% of individuals in `cx_pop` should now be children with crossovers.  We'll print out the first 6 members of the population before and after crossover to see what happened.  If crossover occurred then the bottom part of each pair should stay the same while the top part of each pair gets swapped.  Compare the parents in the first set of columns to the children in the second set of columns.  You should be able to see where the top part of each pair children is swapped from the parents.","pos":55,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"4e295c","input":"The genetic algorithm does a good job of sifting through all of the local minima (there are $10^{10}$ local min for the 10-dimensional Rastrigin function), but it does a poor job of really zeroing in on the minimum.  For problems with continuous variables local search is usually combined with the genetic algorithm.","pos":68,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"538adb","input":"### Compute Fitness (again)\nWe'll copy `mut_pop` into the original population `pop` and evaluate the fitness before returning to the start of the loop.","pos":64,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"552ed1","input":"## Simulated Annealing for Continuous Optimization","metadata":{"heading_collapsed":true,"hidden":true},"pos":18,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"556862","input":"We found this two-dimensional example in <a href=\"http://apmonitor.com/me575/index.php/Main/SimulatedAnnealing\">this tutorial</a> on simulated annealing.\n\nFind the minimum value of \n$$f(x,y) = 0.2 + x^2 + y^2 - 0.1 \\cos(6 \\pi x) - 0.1 \\cos(6 \\pi y)$$ \n\nfor $-1 \\leq x,y \\leq 1$.  This function is similar to the Rastrigin function and the global minimum value is $f(0,0) = 0$.  A contour plot, shown below, illustrates that there are many local minima (in the center of many of the small loops, some correspond to local maxima).  The <a href = \"http://apmonitor.com/me575/index.php/Main/SimulatedAnnealing\">tutorial</a> itself is worthy of a look and has a nice flow chart outlining how simulated annealing works.","metadata":{"hidden":true},"pos":21,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"55bf61","input":"#### *Self-Assessment for Simulated Annealing with Continuous Variables*\n\nUse the objective and move functions from above to create a class using the `simanneal` package.  Use it to approximate the location of the global minimum for the \"Bumpy\" function above.  You'll notice that you usually will get close to the location of the global minimum at the origin, but it won't be exact because it is very difficult to randomly move exactly to the minimum location.  Usually, for continuous functions simulated annealing is combined with local search in an iterative procedure (we'll see an example of this in the homework with the `dual_annealing` optimizer from the `scipy.optimize` package.  For this example you could take the best state found by simulated annealing and use it to start a local search using `minimize` from `scipy.optimize` package.\n\nThe code from the TSP example above is a good starting point.  Instead of the distance matrix you'll need to pass the scale parameter sigma to determine the size of the moves.  A good starting point for sigma is range/6 where range = upper bound - lower bound.  This value for sigma is because a normal distribution is about 6 * sigma wide.  You may want to experiment with the value of sigma to see how it effects the result of simulated annealing.  You could also play with the time allowed when you set the schedule for the annealing.","pos":26,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"5f8cfb","input":"Think of a genetic algorithm as a smart version of random search.  Genetic algorithms are great at exploring large search spaces but sometimes aren't so good at zeroing in on a solution once they've gotten close to a good solution.\n\nYou should have read about the basics of genetic algorithms in the textbook.  Genetic algorithms are a vast subject and we'll just scratch the surface.  Fortunately there seem to be tons of free tutorials and other resources available for learning more about genetic algorithms.  The pseudocode for a genetic algorithm is as follows:\n```\ngenerate the initial population\ncompute fitness\nrepeat\n    selection\n    crossover\n    mutation\n    compute fitness\nuntil population has converged\n```\n\nHere are just a few notes about the algorithm:\n* population = set of trial solutions that are also called individuals (or chromosomes)\n* fitness = objective function\n* selection = choosing the most promising solutions in the current population but leaving a few bad ones for diversity\n* crossover = combining or breeding the selected solutions to generate new candidate solutions\n* mutation = randomly tweaking some of the solutions in the current population to encourage exploration of the solution space\n\nWe will write our own genetic algorithms so that we can get a better understanding of their ingredients.  Before we dive into the details we summarize some packages you could explore to apply genetic algorithms to your optimization problems.\n\n## Genetic Algorithm Packages\n\nIf you need to use genetic algorithms in practice, it's probably better to seak out a package that has that functionality.  Some options include:\n* <a href=\"https://github.com/deap/deap\" target=\"_blank\">The DEAP package</a>.  This package is for genetic programming.  It's very powerful and flexible, but also abstract with a significant learning curve.  It's worth learning if you often need to use genetic algorithms or other types of evolutionary algorithms.\n* <a href=\"https://pypi.org/project/geneticalgorithm/\" target=\"_blank\">The geneticalgorithm package</a> This package is an easy to use, but limited, genetic algorithm for minimization.  It supports either real or integer variables.  It can't be used for problems with permuations such as TSP.  Also the objective function can have only one argument so if you need additional data (e.g. the distance matrix) the function will have to find the data in the global scope.  It's slow with the default settings.\n* The `deap_wrapper` package.  This is something we've been working on but at the moment it's not a well documented package.  If you're curious you can see examples of how to use it in the notebook `deap_wrapper_examples.ipynb` in the same folder as this lesson.\n* The `GA` package in R.  This is a really easy to use implementation of the genetic algorithms that handles several types of variables.  Documentation is <a href=\"https://cran.r-project.org/web/packages/GA/\" target=\"_blank\">here on CRAN</a>.  In our experience this is a lot easier to use than DEAP.  The notebook `Genetic_Algorithm_with_R.ipynb` gives an example and shows how you can include R in a Python Jupyter notebook (it's pretty cool).","metadata":{"hidden":true},"pos":30,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"610187","input":"For mutation of permutation variables it is common to use Shuffling Indices.  To do just make a copy of the individual then loop over each variable and with probability `ind_prob` swap it with another randomly selected variable in the individual.  It's possible that you may end up swapping a variable with itself, but that's OK.\n\nTo initialize you'll to use a loop since it's only possible to create one random permutation at a time.\n\n**Example Initialization:**\n\nThe code below creates a population of ten sequences with values 0 to 7.","pos":72,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"6a9d11","input":"Simulated annealing was designed for combinatorial (discrete) optimization problems, but has been adapted to continuous optimization problems.  The main issue is how to generate a new move at each iteration.  There are many variations, but often the move is selected at random from a suitable probability distribution such as a normal or uniform distribution.\n\nThe objective functions we consider here aren't from real applications, instead they're chosen to give you an idea how the algorithm works for difficult optimization problems with many local optima.  It's good to have this sort of thing in mind when, for instance, you're trying to train a complicated neural network and have to optimize the weights in the network to find the best fit to your data.","metadata":{"hidden":true},"pos":19,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"6e1868","input":"# Simulated Annealing","metadata":{"heading_collapsed":true},"pos":3,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"74bee2","input":"Copy the gerrymandering code from Lesson 4 and adapt the genetic algorithm code above to try to find a solution in which republicans win 8 or 9 of the 10 districts.  Beware that you're trying to maximize the fitness.  The simplest way to use a minimization algorithm to maximize is to negate the fitness value.  If you start with simanneal_tsp then you should need only minor changes.\n\nTo make the genetic algorithm work, you'll need to pay attention to the following:\n* The initial population should be individuals of length 18 (`num_cities`) each having integer values between 0 and 9 with repeats allowed (there are `num_districts = 10` voting districts).  Use `numpy.random.randint`\n* You can use one-point crossover to mate individuals.  That part of the code doesn't need to change at al.  \n* For mutation you could change some of the district assignments in an individual randomly (use `ind_prob`).  Use `numpy.random.randint` to generate mutations for each variable.  The `move_one_district` function from Lesson 4 actually changes only one city so it isn't quite what we want here.\n* You may need to cast the population as integers before you evaluate the fitness function (or do it in the fitness function) using something like this:  `pop = pop.astype(int)`","metadata":{"hidden":true},"pos":76,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"761a68","input":"## Genetic Algorithm Step by Step\n\nWe'll write a genetic algorithm to minimize a 10 dimensional (10 input variables) Rastrigin function.  The population will be stored in a numpy array with the individuals stored as columns so the array will have 10 rows (one for each input variable) and the number of columns will correspond to the population size.  The full algorithm is in one cell further below, but first we'll break down each step.\n\n**For more help go here:** A fantastic place to get more details about genetic algorithms and the various bits and pieces is this <a href=\"https://www.tutorialspoint.com/genetic_algorithms/index.htm\" target=\"_blank\">free online tutorial at tutorialspoint.com.</a>\n\n### Generate the Initial Population\nWe'll make our initial population have 50 individuals (sometimes called chromosomes)","pos":31,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"7679a0","input":"We'll add the \"repeat\" loop at the end when we put all of this together but first we'll apply each of the operators: selection, crossover, and mutation.\n\n### Selection\n\nWe want to select the fittest individuals from the population for breeding (crossover and mutation), but we also want to maintain diversity in the population so that breeding produces a variety of offspring to encourage exploration of the search space.\n\nWe'll implement tournament selection where we'll first choose a subset of individuals from the population and then select the fittest member of that subset for the new population.  The number of individuals in each subset is called the tournament size.  The larger the size of the tournament the more likely that only the fittest members of the population are selected for the next generation.  Small tournament sizes mean that less fit individuals have a chance to be selected.  We'll use a `tourn_size = 3`.  You can read a bit about other selection operators in any genetic algorithms textbook.  A small explanation about some selection operators can be found on <a href=\"https://en.wikipedia.org/wiki/Selection_(genetic_algorithm)#d._Tournament_Selection\">Wikipedia.</a>\n\nTo  facilitate selection we'll first sort the numpy array `pop` so that the individuals (columns) are ordered by increasing fitness.  Since we're minimizing the objective function the most fit individual will be in the first column and the least fit individual will be in the last column.  One way to do this sorting is to use `argsort()` which returns the positions of the sorted individuals in the original list.","pos":39,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"7bba20","input":"Now we'll apply argsort to the fitness values and use sort_pos to order both the fitness values and columns of the population:","pos":43,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"7cfb96","input":"The goal of global optimization is to find the global optimimum value which means we want to identify the best possible soluiton in the entire search space.  However for many problems the search space is too large and/or the function landscape is too complicated to guarantee that the best solution can be found.  \n\nA metaheuristic algorithm attempts to find a good solution without any guarantee of being able to find the best solution.  Often metaheuristics are stochastic in nature, that is they incorporate randomness as an element of the search, but they aren't generally completely random in nature.  They often incorporate search patterns which are known to work well for the problem at hand.\n\nUnfortunately there is no single algorithm which works best for all classes of problems.  This is often referred to as a \"no free lunch theorem\" in optimization.  We'll focus on the two stochastic optimization algorithms that are described in your textbook:  simulated annealing and genetic algorithms.  ","metadata":{"hidden":true},"pos":2,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"85b940","input":"We didn't actually need to save the fitness values for the selected individuals, but we did so that you can see the effect of selection.  If you look at the fitness values from the original population and the selected population fitness values you should notice that there are fewer large values and more small values in the selected population.  You may also see that there are repeats since it's likely that the fittest individuals are selected more than once.  That's selection in action:","pos":47,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"88cddd","input":"## Simulated Annealing with TSP (video)","metadata":{"hidden":true},"pos":5,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"8b68e3","input":"Let's print the first five columns to see what we have:","pos":33,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"910724","input":"### Compute Fitness\n\nWe want to apply the Rastrigin function to each individual or column in the numpy array `pop`. For a numpy array it's possible to do the computation in couple of lines without a loop, but that wouldn't generalize well to some of our other objective functions.  Instead we'll define our Rastrigin function and then use a loop to iterate over all the individuals in the population.","pos":35,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"925d40","input":"Think of simulated annealing as an enhanced local search that allows some moves that don't improve the best function value to try to climb\n\nIn a hill-climbing local search we only allow moves that increase the objective function value.  \n\nHere is our pseudo-code from the previous lesson for **Local Search:**\n```\n set starting state \n while local_condition \n     select a move \n     if acceptable \n         do the move \n         if new optimum \n             remember it \n endwhile \n ```\n\nSimulated annealing is a trajectory based method for generating a sequence of solutions and is similar our basic \"hill-climbing\" local search algorithm.  In a strict hill-climbing algorithm we only allow uphill moves, but in simulated move we sometimes allow downhill moves and are more likely to allow downhill moves in the early part of the search.  The idea is that to find the tallest peak in a mountain range we have to first descend from a lower peak.\n\nThe probability of a downhill move is determined by a temperature parameter that decreases throughout the search.  The probability of a downhill move depends on the size of the downhill move compared to the temperature.  At high temperatures large and small downhill moves are probable, but as the temperature decreases only small downhill moves are probable so that the search performs similarly to a local search at low temperatures.\n\nHere is pseudo-code for **Simulated Annealing:**\n```\n set starting state and initial temperature\n while local_condition \n     select a move \n     if acceptable \n         do the move \n         if new optimum or random # < probability determined by temperature\n             remember it\n     decrease temperature\n endwhile \n ```\n \nChoosing the initial temperature and the manner in which the temperature decreases are critical to the performance of simulated annealing.  We'll start with a temperature schedule that looks like this:\n$$ T = T_0 \\alpha^n.$$\nWhere $T_0$ is the initial temperature, $0 < \\alpha < 1,$ and $n$ is the number of iterations.   This is called geometric temperature decay, but many other choices are possible.  In the next section we'll demonstrate simulated annealing for the traveling salesman problem.\n\nIn the next section we present simulated annealing using our own code so that you can see how it works, but in general we'll use the `simanneal` package that will be introduced further below.","metadata":{"hidden":true},"pos":4,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"92def6","input":"### *Self-Assessment:  Crossover probability*\nWhat happens if `cx_prob = 0`?  What happens if `cx_prob=1`?","pos":58,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"94391b","input":"If everything is working well, then the fitness of the population should be generally be decreasing, but it's hard to tell if that is the case by looking at the fitness values from one iteration of the genetic algorithm.  Now we'll put it all together in a loop and track the best fitness found overall and in each generation.\n\n### Adjustable Parameters Overview\n\n<table >\n\t<tbody>\n\t\t<tr>\n            <td><b>parameter</b></td>\n            <td><b>variable name</b></td>\n            <td><b>lower bound</b></td>\n            <td><b>upper bound</b></td>\n            <td><b>typical value(s)</b></td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>population size</td>\n\t\t\t<td><code>pop_size</code></td>\n\t\t\t<td>2</td>\n\t\t\t<td>none</td>\n\t\t\t<td>number of variables * (5 to 20)</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>individual size</td>\n\t\t\t<td><code>ind_size</code></td>\n\t\t\t<td>NA</td>\n\t\t\t<td>NA</td>\n\t\t\t<td>always = number of variables</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>lower bound for real var.</td>\n\t\t\t<td><code>lower</code></td>\n\t\t\t<td>NA</td>\n\t\t\t<td>NA</td>\n\t\t\t<td>problem dependent</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>upper bound for real var. </td>\n\t\t\t<td><code>upper</code></td>\n\t\t\t<td>NA</td>\n\t\t\t<td>NA</td>\n\t\t\t<td>problem dependent</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>tournament size for selection</td>\n\t\t\t<td><code>tourn_size</code></td>\n\t\t\t<td>1</td>\n\t\t\t<td><code>pop_size</code></td>\n\t\t\t<td>3 to 5</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>crossover probability</td>\n\t\t\t<td><code>cx_prob</code></td>\n\t\t\t<td>0.0</td>\n\t\t\t<td>1.0</td>\n\t\t\t<td>0.8</td>\n\t\t</tr>\n        <tr>\n\t\t\t<td>mutation probability</td>\n\t\t\t<td><code>mut_prob</code></td>\n\t\t\t<td>0.0</td>\n\t\t\t<td>1.0</td>\n\t\t\t<td>0.2</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>single var. mutation prob.</td>\n\t\t\t<td><code>ind_prob</code></td>\n\t\t\t<td>0.0</td>\n\t\t\t<td>1.0</td>\n\t\t\t<td>0.05 to 0.1</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>real var. mutation size</td>\n\t\t\t<td><code>sigma</code> </td>\n\t\t\t<td>&#62 0.0</td>\n\t\t\t<td>none</td>\n\t\t\t<td>(upper-lower)/6</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>number of iterations</td>\n\t\t\t<td><code>num_iter</code></td>\n\t\t\t<td>1</td>\n\t\t\t<td>none</td>\n\t\t\t<td>problem dependent</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>update to screen interval</td>\n\t\t\t<td><code>update_iter</code></td>\n\t\t\t<td>1</td>\n\t\t\t<td><code>num_iter</code></td>\n\t\t\t<td><code>num_iter/20</code></td>\n\t\t</tr>\n\t</tbody>\n</table>\n\n\n### Putting it Together\n\nFor our loop we'll just iterate a fixed number of times.  A more sophisticated genetic algorithm would monitor the convergence and use a dynamic stopping criteria.  Our implementation is not particularly efficient since the code was written for transparency and not efficiency ... this may be slow!\n\nThe goal for our genetic algorithm code is to increase your understanding of the genetic algorithm.  In truth, this is pretty lousy code if you're trying to use a genetic algorithms in a production setting. In practice it would be better to make the code modular by writing separate functions for each step and then having a master function to run the algorithm.  Or better still would be to use a package such as DEAP.","pos":66,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"9dda44","input":"### Crossover (Mating)\n\nAt this point, the individuals in `select_pop` are in a random order after selection (if they weren't then we should shuffle them before continuing) so we're going to loop over pairs of individuals and with probability `cx_prob = 0.8` each pair will produce a pair of offspring using <a href=\"https://en.wikipedia.org/wiki/Crossover_(genetic_algorithm)\"> One Point Crossover </a> (<a href=\"https://en.wikipedia.org/wiki/Crossover_(genetic_algorithm)\">other kinds of crossover</a> are possible too) We randomly choose a \"crossover point\" and swap the two pieces of the two individuals.  The image below illustrates this nicely:\n\n<img src=\"./images/OnePointCrossover.png\" width=400>\n\nIn the next cell is a bit of Python that illustrates how One Point Crossover works when the crossover point is 3.","pos":51,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"9e8dfa","input":"### Mutation\n\nMany mutation operators are possible, but for real-valued variables such as those we are using to minimize the Rastrigin function, Gaussian Mutation is very common.  First we loop over the individuals in `cx_pop` and with probability `mut_prob` we mutate the individual.  If mutation occurs we loop over the `ind_size = 10` variables and with probability `ind_prob = 0.1` we add a random number from a normal distribution with mean 0 and standard deviation `sigma = 10.24/6`.  Just like when we used simulated_annealing above we choose sigma by fitting six standard deviations in the range of each variable from -5.12 to 5.12 (this is a guideline; smaller or larger mutations could be used).  Like we did with simulated annealing we'll also clip each mutated individual to stay inside the bounds.  Usually we'll set `mut_prob` to a value like 0.2, but we'll run it below with `mut_prob = 1.0` so we can see the mutations in some of the variables.","pos":59,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"a2d6cb","input":"The `simanneal` package is pretty straightforward to use. Using the simanneal package has a couple of advantages over our version of simulated annealing above.  First, we don't have to worry about the algorithm framework.  Second, we don't have to worry about figuring out a temperature schedule.  While it's possible to specify a temperature schedule, it is far easier to use the `auto` scheduler and specify the approximate amount of time we'd like to wait for a solution\n\nThe package works by making an object of the Annealer class and then calling the anneal method on that object. To set up a problem we have to set three things in our instance of the Annealer class.\n\n1.  the state initializer \n2.  the move function that tells the anneal how to generate new moves\n3.  the fitness function (fitness is called energy in this package and it was called objective in the locsearch package in Lesson 4).\n\nThe anneal method appears to always find minima so you may have to negate your function if you want to find a maximum. The <a href=\"https://github.com/perrygeo/simanneal\">Github page</a> has some short documentation about the simanneal package.","metadata":{"hidden":true},"pos":13,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"a80b2d","input":"We'll use the seven city example TSP from the textbook. Find the shortest tour (or cheapest cost) to visit all 7 cities and return to the starting city in the following graph:\n\n<img src=\"./images/HillierTSP.png\" width=400>\n\nWe'll store all of the intercity distances in a two dimensional list that we call distance_matrix. For cities that aren't connected we'll use the \"bigM\" method and introduce a distance of 100 between those pairs of cities so that those routes won't be included in the tour. Note that the picture labels the cities 1 through 7, but in Python we'll use 0 through 6.  The data is stored in the included json file.\n","metadata":{"hidden":true},"pos":7,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"aef838","input":"To use simulated annealing to optimize a function with continuous variables isn't all that different than how we used it to find a good, or even optimal, tour in the traveling salesman problem.  \n\nWe're going to rely on the `simanneal package` in the rest of this lesson because it's much more robust than our \"homebrewed\" code in the `simanneal_tsp()` function above. \nTo use the package we'll have to generate an initial state, define the `energy()` method for returning the objective function value, and define the `move()` method for making a move from a current state to a new state.\n\nTo generate an initial state you could select uniformly distributed random numbers between -1 and 1:\n```\ninit_state = np.random.uniform(low=-1, high=1, size=2)\n```\n\nWe like to write functions for computing the objective function value and for making moves and then call those functions from the `move()` and `energy()` methods in the class definition for our problem as we did in the simanneal package TSP example above.\n\nWe already have the objective function from where we made the contour plot:\n```\ndef f(xy):\n    obj = 0.2 + sum(xy**2 - 0.1*np.cos(6*np.pi*xy))\n    return obj\n```\n\nMaking a move will consist of applying two functions successively.  The first function adds normally distributed random numbers to each variable while the second function clips values that are out of the $[-1,1]$ bounds.  The scale of the move will need to be passed to the first function, while the values of the lower and upper bounds need to be passed to the clipping function.  These values will need to be initialized in the `__init__` constructor similar to how we worked with the distance matrix in the TSP example.  Here are the functions:\n```\ndef gauss_move(xy,sigma):\n    # xy is a 1 by dim numpy array\n    # sigma is the standard deviation for the normal distribution\n    dim = len(xy)\n    return xy + np.random.normal(loc = 0, scale = sigma, size=dim)\n\ndef clip_to_bounds(xy,low,high):\n    # xy is a 1 by dim numpy array\n    # low is the lower bound for clipping variables\n    # high is the upper bound for clipping variables\n    return np.array( [min(high,max(low,v)) for v in xy])\n```","metadata":{"hidden":true},"pos":25,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"b2a3c1","input":"To do tournament selection we'll randomly choose 3 integers between 0 and 49, say (3,27,38) and have a tournament between those three individuals.  Since the individual in column 3 is the fittest (in the sorted population) we'll select that individual.  Here is some code to do the tournament selection:","pos":45,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"bdf3bb","input":"#### *Self-Assessment:  Mutation Parameters:*\n\n* What is the effect of `mut_prob = 1`?\n* What is the effect of `mut_prob = 0`?\n* What is the effect of increasing `ind_prob`?\n* What would happen if you made `sigma` really large?\n* What would happen if you made `sigma` really small?","pos":63,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"c37884","input":"#### *Self-Assessment:  Exploring Tournament Selection*\n\nTry running the tournament selection code above with both smaller and larger tournament sizes.  What happens for smaller tournament sizes?  For larger tournament sizes?  For tournament size 1?  For tournament size the same as the population size?","pos":50,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"c431bb","input":"#### *Self-Assessment:  Refine the best solution with local search*\n\nRun the genetic algorithm on the Rastrigin function above until you're satisfied the output is near the global minimum.  Now take the location of the minimizer, `best_x`, and apply \n`minimize` from the `scipy.optimize` to get closer to the minimum value.  How does this approach compare to the multistart approach used on the 10-dimensional Rastrigin function in Lesson 4?  Which approach is more efficient?","pos":69,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"c58ad1","input":"# Homework Ideas\n\n* SA for knapsack\n* SA with local search on Rastrigin\n* ask \"theory\" questions like \"how do configure the GA for Rastrigin so that it's purely random search with no sharing of information between individuals in the population?\" \n* replace one point crossover with blended crossover for Rastrigin\n* get GA working for TSP by adapting DEAP code from Github\n* get GA working for knapsack problem.  (give answer of 435)\n* modify GA to stop after no improvement for some number of iterations","pos":79,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"ccdd48","input":"### *Self Assessment: Simulated Annealing for Gerrymandering*","metadata":{"heading_collapsed":true,"hidden":true},"pos":10,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"d9deca","input":"### A non-convex 2D example","metadata":{"heading_collapsed":true,"hidden":true},"pos":20,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"e669a4","input":"## Mating, Mutation, and Initialization for Other Variable Types\n\nThe Rastrigin example above demonstrates One Point Crossover and Gaussian Mutation for problems with real variables, but other common scenarios include integer, binary, and permutation variables.  We can't even begin to cover all of the possible crossover and mutation operators (these are just what the algorithms are called in genetic algorithm world), but we'll mention a few that you'll explore in the homework.\n\n### Real Variables (Rastrigin)\n\nGaussian mutation is common, but One Point Crossover is not as common as Blended Crossover for real variable optimization.  In Blended Crossover, or BX$\\alpha$-crossover, each new variable in the resulting child is chosen from an interval that overlaps the two parents.  The following picture helps explain it:  \n\n<img src=\"images/blended_crossover.png\" width = 400>\n\nLet $x_i$ and $y_i$ be the variables from the two parents with $x_i < y_i$.  The idea is to sample uniformly from an interval that includes $x_i$ and $y_i$ but is expanded by, for example 20%, in each direction.  The exact amount of expansion is determined by the parameter $\\alpha$ which is usually between 0 and 1.  Values of $\\alpha$ are typically around 0.1 or 0.2.  \n\nFor each new variable, $z_i$ in the child here is the algorithm:\n1.  extract the corresponding variables $x_i$ and $y_i$ from the parents\n2.  find the min and max of $x_i$ and $y_i$ then range = $|x_i - y_i|$\n3.  the new variable $z_i$ is a random uniform number in the range [ min - $\\alpha$ * range, max + $\\alpha$ * range]\n\nSo if a pair of parents is randomly selected to mate, then form two children by looping (twice) over the parent variables and following the algorithm above for each pair.\n\nBlended Crossover seems to work better than One Point Crossover for problems with real variables.\n\n**Example initialization:**\n```\npop = np.random.uniform(3,5,size=(4,10))\n```\nCreates a $4 \\times 10$ array of random real numbers in the range [3,5].\n\n### Integer Variables (Gerrymandering Problem)\n\nThe individuals consist of integer values variables from a certain range.  One Point Crossover is suitable for mating  although other choices are possible.  A common mutation operator is to consider each integer $x_i$ in the individual and change it, with probability `ind_prob`, to a randomly sampled integer, $z_i$ from the suitable range.\n\n**Example initialization:**\n```\npop = np.random.randint(-5,23,size=(4,10))\n```\nCreates a $4 \\times 10$ array of random integers in the range [-5, 23].  This corresponds to `pop_size = 10` and `ind_size = 4.`\n\n\n### Binary Variables (Knapsack Problem)\n\nBinary variables are a special case of integer variables with only 0 and 1 allowed.  One Point Crossover is common here.  Mutations are commonly called \"flipping a bit\" because 0's are toggled to 1's and 1's to 0's.  In a bit flipping mutation each variable is randomly switched with probability `ind_prob`.\n\nIt is common to represent the binary variables as 0 and 1 or as False and True boolean variables.  Either one can be used in the homework.\n\n**Example initialization:**\n```\n# 0 and 1\npop = np.random.randint(0,2,size=(4,10))\n# False and True\npop = np.random.randint(0,2,size=(4,10)).astype(bool)\n```\nCreates binary populations.  Recall that when specifying a range of integers in Python most packages and data structures don't include the top number in the range.\n\n### Permutation Variables (TSP)\n\nThese can come from problems where we are looking for the best order for a process of some kind.  For instance in the Traveling Salesman Problem we are trying to find the order to visit cities 1 through 7 (and back to 1) that minimizes the total distance traveled.  The crossover and mutation operators we've discussed so far don't work in this situation.\n\nA commonly used form of crossover is called Ordered Crossover in which two subsequences are swapped between the parents and the remainder of the variables filled in by preserving the order of variables.  The video below gives an example of how this works.\n\nINSERT VIDEO HERE.\n\nThe next cell contains code (also discussed in the video) that you can adapt to do Ordered Crossover in the homework.","pos":70,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"e814ed","input":"Here is some code to produce a new population from `select_pop` using One Point Crossover.","pos":53,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"e90c83","input":"Here is a 3D plot that makes it easier to see all of the local minima in the search space.  A local search will easily get stuck in the wrong minimum if the initial search point isn't very close to the origin.","pos":23,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"ebd88a","input":"Notice that we get close to the optimal solution, but only to within 5 or so decimal places.  Simulated annealing is very good at exploring the entire space of solutions but is not so efficient at converging to a nearby minimum value.  Most practical simulated annealing type search algorithms for continuous optimization combine a gradient based local search with the annealing process to promote faster convergence.","metadata":{"hidden":true},"pos":28,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"ebe6f3","input":"#### *Self-Assessment:  Genetic Algorithm for the Gerrymandering Problem*","pos":75,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"f187e8","input":"Use the `simanneal` package to try to find a solution in which republicans win 9 of the 10 districts.  Beware that you're trying to maximize the fitness so you'll either need to use a negated fitness function.  You'll also have to set the cities data frame in the initializer (similar to the distance matrix in the tsp above).  The set up here is very similar to using the `locsearch` package to solve the gerrymandering problem as we did in the last self-assessment in Lesson 4.\n\nIf you're using the auto option for the temperature schedule then it could take several minutes to complete a run because the search space for this problem is huge.  Each entry in the 18 dimensional vector can be a number 0 through 9 so there are $10^{18}$ possible vectors to explore.  Alternately you can manually set the temperature schedule with something like this:\n\n```\ntsp.Tmax = 5000\ntsp.Tmin = 2.5\ntsp.steps = 5000\ntsp.updates = 100\n```\n\nYou should replace tsp with the appropriate name that you setup in your code and also experiment with the numbers.  Make sure to comment out the auto schedule.  ","metadata":{"hidden":true},"pos":17,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"f57356","input":"### *Self Assessment: Simulated Annealing for Gerrymandering*","metadata":{"hidden":true},"pos":16,"state":"done","type":"cell"}
{"cell_type":"markdown","id":"fc016f","input":"# Genetic Algorithms","metadata":{"heading_collapsed":true},"pos":29,"state":"done","type":"cell"}
{"id":0,"time":1597116089920,"type":"user"}
{"last_load":1597164384337,"type":"file"}